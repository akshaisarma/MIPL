/*
 * MIPL: Mining Integrated Programming Language
 *
 * File: InstructionWriter.java
 * Author A: YoungHoon Jung <yj2244@columbia.edu>
 * Author B: Akshai Sarma <as4107@columbia.edu>
 * Reviewer: Younghoon Jeon <yj2231@columbia.edu>
 * Description: Instruction Writer
 */
package edu.columbia.mipl.codegen;

import java.util.*;

import edu.columbia.mipl.runtime.*;
import edu.columbia.mipl.datastr.*;

/**
 * InstructionWriter is an abstract class that defines the APIs
 * in order to traverse each node of Abstract Syntax Tree generated by
 * the MIPL Compiler's Front End.
 * The Abstract Syntax Tree given will be traversed in the Post-order.
 * An instanciation of InstructionWriter's subclasses will
 * automatically register the class to the InstructionWriterFactory.
 */
public abstract class InstructionWriter {
	InstructionWriter() {
		InstructionWriterFactory.registerInstructionWriter(this);
	}

	/**
	 * Sets the path and file name to write the resulted code.
	 * @param path the path name
	 * @param filename the file name
	 */
	public abstract void init(String path, String filename);

	/**
	 * Gets the name of the InstructionWriter Subclass
	 * i.e) JavaSrc or Bytecode
	 * @return the name of the InstructionWriter Subclass
	 */
	public abstract String getName();

	/**
	 * Writes codes that create a Term instance with IS type
	 * @param type should be Term.Type.IS
	 * @param term1 a Term instance with Term.Type.VARIABLE
	 * @param expr1 an Expression instance
	 */
	public abstract void createTerm(Term.Type type, Term term1,
										Expression expr1);
	/**
	 * Writes codes that create a Term instance with Comparison type
	 * @param type should be Term.Type.EQ, Term.Type.LE, Term.Type.LT, Term.Type.GE, Term.Type.GT, or Term.Type.NE
	 * @param expr1 an Expression instance
	 * @param expr2 an Expression instance
	 */
	public abstract void createTerm(Term.Type type, Expression expr1,
										Expression expr2);
	/**
	 * Writes codes that create a Term instance with Matrix type
	 * @param type should be Term.Type.MATRIX
	 * @param name the name of the rules represented by the matrix
	 * @param matrix the values of the rules
	 */
	public abstract void createTerm(Term.Type type, String name,
										PrimitiveMatrix<Double> matrix);
	/**
	 * Writes codes that create a Term instance with two-Terms type
	 * @param type should be Term.Type.ORTERMS or Term.Type.ANDTERMS
	 * @param term1 a Term instance
	 * @param term2 a Term instance
	 */
	public abstract void createTerm(Term.Type type, Term term1, Term term2);
	/**
	 * Writes codes that create a Term instance with not-Term type
	 * @param type should be Term.Type.NOTTERM
	 * @param term1 a Term instance
	 */
	public abstract void createTerm(Term.Type type, Term term1);
	/**
	 * Writes codes that create a Term instance with Term type
	 * @param type should be Term.Type.TERM or Term.Type.REGEXTERM
	 * @param name the name of the Term
	 * @param arguments the Term's arguments
	 */
	public abstract void createTerm(Term.Type type, String name,
										List<Term> arguments);
	/**
	 * Writes codes that create a Term instance with Number type
	 * @param type should be Term.Type.NUMBER
	 * @param value the numeric value of the Term
	 */
	public abstract void createTerm(Term.Type type, double value);
	/**
	 * Writes codes that create a Term instance with Variable type
	 * @param type should be Term.Type.VARIABLE
	 * @param name the name of the Variable
	 */
	public abstract void createTerm(Term.Type type, String name);
	/**
	 * Writes codes that create a Term instance with Expression type
	 * @param type should be Term.Type.EXPRESSION
	 * @param expr1 an Expression instance
	 */
	public abstract void createTerm(Term.Type type, Expression expr1);

	/**
	 * Writes codes that create an Expression instance with Term type
	 * @param type should be Expression.Type.TERM
	 * @param term a Term instance
	 */
	public abstract void createExpression(Expression.Type type, Term term);
	/**
	 * Writes codes that create an Expression instance with Computation type
	 * @param type should be Expression.Type.MINUS, Expression.Type.PLUS, Expression.Type.MULTI, or Expression.Type.DIVIDE
	 * @param expr1 an Expression instance
	 * @param expr2 an Expression instance
	 */
	public abstract void createExpression(Expression.Type type, Expression expr1,
											Expression expr2);

	/**
	 * Writes codes that create a Fact instance with Fact type
	 * @param type should be Fact.Type.FACT
	 * @param term a Term instance
	 */
	public abstract void createFact(Fact.Type type, Term term);
	/**
	 * Writes codes that call the Job and create facts from the results
	 * @param type should be Fact.Type.MATRIXASFACTS
	 * @param name the name of the facts, represented by the matrix
	 * @param names the list of the names that will store the result matrices from the job calling
	 */
	public abstract void createFact(Fact.Type type, String name,
										List<String> names, List<Term> terms);

	/**
	 * Writes codes that create a Rule instance
	 * @param term a Term instance which will be the left-side Term of the rule
	 * @param source a Term instance which will be the right-side Term of the rule
	 */
	public abstract void createRule(Term term, Term source);

	/**
	 * Writes codes that create a Query instance
	 * @param term a Term instance
	 */
	public abstract void createQuery(Term term);

	/**
	 * Writes codes that declare a Job
	 * @param name the name of the Job
	 * @param args the arguments of the Job
	 * @param stmts the list of the JobStmts in the Job
	 */
	public abstract void createJob(String name, List<Term> args,
									List<JobStmt> stmts);

	/**
	 * Writes codes that work as described in this control-flow JobStmt
	 * @param type should be JobStmt.Type.IF, JobStmt.Type.WHILE, or JobStmt.Type.DOWHILE
	 * @param expr a JobExpr instance for the condition expression
	 * @param stmt1 a JobStmt instance for the if, while, and do-while statement
	 * @param stmt2 a JobStmt instance for the else statement
	 */
	public abstract void createJobStmt(JobStmt.Type type, JobExpr expr,
										JobStmt stmt1, JobStmt stmt2);
	/**
	 * Writes codes that work as described in this Compound JobStmt
	 * @param type should be JobStmt.Type.COMPOUND
	 * @param stmts a list of JobStmt instances
	 */
	public abstract void createJobStmt(JobStmt.Type type, List<JobStmt> stmts);
	/**
	 * Writes codes that compute the expression and if the type is Return return the result
	 * @param type should be JobStmt.Type.EXPR or JobStmt.Type.RETURN
	 * @param expr a JobExpr instance
	 */
	public abstract void createJobStmt(JobStmt.Type type, JobExpr expr);

	/**
	 * Writes codes that represent the Assignment expression
	 * @param type should be JobExpr.Type.ASSIGN, JobExpr.Type.MULASSIGN, JobExpr.Type.DIVASSIGN, JobExpr.Type.MODASSIGN, JobExpr.Type.ADDASSIGN, or JobExpr.Type.SUBASSIGN
	 * @param expr1 a JobExpr instance
	 */
	public abstract void createJobExpr(JobExpr.Type type, String name,
										JobExpr expr1);
	/**
	 * Writes codes that represent the Binary Operation expression or the Comparison expression
	 * @param type should be JobExpr.Type.OR, JobExpr.Type.AND, JobExpr.EQ, JobExpr.NE, JobExpr.LT, JobExpr.LE, JobExpr.GT, JobExpr.GE, JobExpr.ADD, JobExpr.SUB, JobExpr.MULT, JobExpr.DIV, JobExpr.MOD, JobExpr.MULT_CELL, JobExpr.DIV_CELL, or JobExpr.EXP_CELL
	 * @param expr1 a JobExpr instance
	 * @param expr2 a JobExpr instance
	 */
	public abstract void createJobExpr(JobExpr.Type type, JobExpr expr1,
										JobExpr expr2);
	/**
	 * Writes codes that represent the Negate expression
	 * @param type should be JobExpr.Type.NEGATE
	 * @param expr1 a JobExpr instance
	 */
	public abstract void createJobExpr(JobExpr.Type type, JobExpr expr1);
	/**
	 * @deprecated As of MIPL_04182012_DEBUG_BETA_002, matrix accessing with index is deprecated.
	 * Use the combination of multiplication and UnboundMatrix instead.
	 */
	public abstract void createJobExpr(JobExpr.Type type, Term term,
										List<ArrayIndex> indices1,
										List<ArrayIndex> indices2);
	/**
	 * Writes codes that call a Job inside a Job
	 * @param type should be JobExpr.Type.JOBCALL
	 * @param name the name of the Job to be called
	 * @param exprs the list of JobExpr instances, the arguments for the Job calling
	 */
	public abstract void createJobExpr(JobExpr.Type type, String name,
										List<JobExpr> exprs);
	/**
	 * Writes codes that represents a variable, a number, or a built-in matrix
	 * @param type should be JobExpr.Type.TERM
	 * @param term a Term instance
	 */
	public abstract void createJobExpr(JobExpr.Type type, Term term);

	/**
	 * Finishes the code writing
	 * i.e) closing the file handle
	 */
	public abstract void finish();
}
