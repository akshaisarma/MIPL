% acmsmall-sample.tex, dated 4th Nov. 2011
% This is a sample file for ACM small trim journals
%
% Compilation using 'acmsmall.cls' - version 1.2, Aptara Inc.
% (c) 2010 Association for Computing Machinery (ACM)
%
% Questions/Suggestions/Feedback should be addressed to => "acmtexsupport@aptaracorp.com".
% Users can also go through the FAQs available on the journal's submission webpage.
%
% Steps to compile: latex, bibtex, latex latex
%
% For tracking purposes => this is v1.2 - Nov. 2011

\documentclass[prodmode,acmtecs]{acmsmall}

% Package to generate and customize Algorithm as per ACM style
\usepackage[ruled]{algorithm2e}
\usepackage{listings}
\usepackage{longtable}
\renewcommand{\algorithmcfname}{ALGORITHM}
\SetAlFnt{\large}
\SetAlCapFnt{\large}
\SetAlCapNameFnt{\large}
\SetAlCapHSkip{10pt}
\IncMargin{-\parindent}

% Metadata Information
\acmVolume{1}
\acmNumber{1}
\acmArticle{1}
\acmYear{2012}
\acmMonth{3}

% Document starts
\begin{document}

% Page heads
%\markboth{Young Hoon et al.}{MIPL Reference Manual}

% Title portion
\title{{MIPL: Mining Integrated Programming Language\\
Language Reference Manual}}
\author{Project Manager: Younghoon Jeon $<yj2231@columbia.edu>$\\
System Architect: Young Hoon Jung $<yj2244@columbia.edu>$\\
Language Expert: Jinhyung Park $<jp2105@columbia.edu>$\\
System Integrator: Daniel Wonjoon Song $<dws2127@columbia.edu>$\\
System Validation: Akshai Sarma $<as4107@columbia.edu>$
%\affil{Columbia University}
}

\begin{abstract}
Abstraction here.
\end{abstract}

%\category{C.2.2}{Computer-Communication Networks}{Network Protocols}

%\terms{Design, Algorithms, Performance}

%\keywords{Wireless sensor networks, media access control,
%multi-channel, radio interference, time synchronization}

%\acmformat{Zhou, G., Wu, Y., Yan, T., He, T., Huang, C., Stankovic,
%J. A., and Abdelzaher, T. F.  2010. A multifrequency MAC specially
%designed for  wireless sensor network applications.}

%\begin{bottomstuff}
%This work is supported by the National Science Foundation, under
%\end{bottomstuff}

\maketitle

\tableofcontents 

\lstset{frame=single}

\section{Introduction}

Introduction here.

Item sample.
\begin{itemize}
\item item1 To the best of our knowledge, the MMSN protocol is the first
\item item2 Instead of using pairwise RTS/CTS frequency negotiation
\end{itemize}

% Head 1
\section{Lexical conventions}
MIPL has six kinds of tokens: identifiers, variables, numbers, strings,
expression operators, and other separators.  In general blanks, tabs,
newlines, and comments as described below are ignored except as they
serve to separate tokens. At least one of these characters is required
to separate otherwise adjacent identifiers, constants, and certain
operatorpairs.  If the input stream has been parsed into tokens up
to a given character, the next token is taken to include the longest
string of characters which could possibly constitute a token.

% Head 2
\subsection{Comments}

MIPL uses shell script-like comments, which begins with the character
\# and terminates at the end of the line, separated by the newline character.

% Head 3
\subsection{Identifiers}

An identifier is a sequence of letters that begins with lower case alphabets.
Upper and lower case letters are considered different.   Identifiers are
served for use as the name of Terms, the basic block of MIPL syntax.

\subsection{Variables}

A variable is a sequence of letters that begins with upper case alphabets
or the underscore character, \_, which means that this variable will not
be tracked.  Upper and lower case letters in the variable names are
considered different. 

\subsection{Numbers}

A number in MIPL is a floating number.  A number consists of an integer
part, a decimal point, a fraction part, an e, and an optionally signed integer
exponent. The integer and fraction parts both consist of a sequence of digits.
Either the integer part or the fraction
part (not both) may be missing; either the decimal point or the
e and the exponent (not both) may be missing.
Every floating constant is taken to be doubleprecision.

\subsection{Strings}

A string is a sequence of characters surrounded by double quotes or single
quotes.

\subsection{Expression Operators}
Expression Operators will be explained in Built-in Operators and Jobs section.

\section{Data Types}

Data Types here. Need Arithmetic types here. Matrix as a type?

\section{Syntax}

Syntax here

%----------------------------------------------------------JINHYUNG{
\subsection{Program}

A MIPL program is simple. Basically, the MIPL program looks like below:

\begin{lstlisting}
program
	: commands
	;
\end{lstlisting}

The MIPL program consists of commands. Each command consists of commmands again.
 MIPL also has the interpreter, so this command is a running unit for the interpreter.
 Here is the sample MIPL program:

\begin{lstlisting}
countPositive(A, SizeOfA) {
    I = 0.
    while (I < SizeOfA) {
        if (A[I] > 0) {
            I = I + 1.
        }
    }
}
cat(tom).
cat(tom)?
animal(X) <- cat(X).
animal(tom)?
\end{lstlisting}

This is the example of the MIPL program. In this example, there are five commands:
 $countPositive\{\}, cat()., cat()?, animal() <- cat().$, and $animal()?$. Each
 command can also include other commands. Each command can be identified by these:
 $\{\}, .,$ or $?$. These are used to determien the command type.\\

\subsection{Commands}

\begin{lstlisting}
commands
	: command commands
	| command
	;
\end{lstlisting}

Including other commands in a command is permissible. The previous example in 4.1
 shows that $countPositive\{\}$ includes several other commands. The command can
 be a $fact$, a $query$, a $rule$, or a $job$.\\

\subsection{Command}

In MIPL, there are four types of commands: $fact$, $query$, $rule$, and $job$.\\

\begin{lstlisting}
command
	: fact
	| query
	| rule
	| job
	;
\end{lstlisting}

\subsubsection{Fact}
\begin{lstlisting}
# fact
cat(tom).
mouse(jerry), mouse(mickey).
\end{lstlisting}

$fact$ is ended with $"."$. $fact$ is used to describe or define the fact, or to
 process a job. So, there are two kinds of facts: one is a static fact, and the other
 is a dynamic fact. A static fact is a normal fact that is ended with $"."$. A dynamic
 fact is wrapped in $[ ]$, so the dynamic fact calls the jab to process data. $fact$
 should be started with the a small letter. Also, several $fact$s can be combined
 in one line with $,$.\\

\subsubsection{Query}
\begin{lstlisting}
# query
cat(tom), mouse(jerry).
mouse(tom)? # Returns false
# query with *
weighted_grade(*)?
\end{lstlisting}

$query$ is ended with $"?"$. $query$ requires facts, or job results. $query$ with
 the fact returns $true$ or $false$. $query$ to the job results returns results 
 satisfying the query. If the fact of the job results have lots of columns, $query$ can
 take $*$ as the query argument to see all results.\\

\subsubsection{Rule}
\begin{lstlisting}
# rule with a fact
animal(X) <- cat(X).
# another rule operator
animal(X) :- cat(X).
# complex rule
animal(X) :- cat(X), dog(X), horse(X).
\end{lstlisting}

$rule$ is defined with $<-$ or $:-$. The rule for fact can be combined with $,$.
 If the first rule cannot be matched, it will try to match the second rule.
 The left of the rule operator would be a fact. The right of the rule operator would
 be a fact, or a job for the rule. If the right of the rule operator is a job,
 the left fact of the rule should be a dynamic fact. When the fact is queried,
 the results of query come from the job or related fact of the rule.\\

\subsubsection{Job}
\begin{lstlisting}
# job
calculate_weighted_grade(G, W) {
 @ bind(G[0][~], G[1~][~] * transpose(W)).
}
# process job with a dynamic fact
[weighted_grade] <- calculate_weighted_grade(grade, weight).
\end{lstlisting}

$job$ is defined with $ IDENTIFIER ( ) { }$. $job$ can be run through MapReduce.
 This behavior is defined by the compiler. If $job$ is big, $job$ will be run
 seperately via MapReduce. If $job$ is small, that operations are run on the
 local system. The job is processed by a dynamic fact, which uses $[ ]$.\\

%----------------------------------------------------------JINHYUNG}
%----------------------------------------------------------YOUNGHOON{

\subsection{Term Expression}
\begin{lstlisting}
term_expr
	: term_expr `+' term_fact
	| term_expr `-' term_fact
	| term_fact
	;
\end{lstlisting}

Term Expression is an expression which belongs to a Term.  Term 
Expressions can consist of binary operators `+' and `-' along with Term
Factors.  These two operators left-associate Term Facts so that Term
Factors within a Term Expression can be computed with a left priority.

Term Expression, Term Factor, and Term Term are basic blocks that
consist Term Expression.  So these three rules can be applied within
Term Expression, by the definition of MIPL grammar.

\subsubsection{Term Factor}

\begin{lstlisting}
term_fact
	: term_fact `*' term_term
	| term_fact `/' term_term
	| term_term
	;
\end{lstlisting}

Term Factor is an expression which belongs to a Term Expression.  Term 
Factors can consist of binary operators `*' and `/' along with Term
Term.  These two operators left-associate Term Terms so that Term
Terms within a Term Factor can be computed with a left priority. Like,
mathematical notations, operators `*' and `/' have higher priority than
operators `+' and `-' since Term Facts are reduced 


\subsubsection{Term Term}
\begin{lstlisting}
term_term
	: VARIABLE
	| NUMBER
	| `(' term_expr `)'
	;
\end{lstlisting}

Term Term is a terminal expression of Term Expression and its derivables,
belonging to a Term Factor.  Term Terms can consist of a Variable or a
Number, which serve as the basic blocks of Term Expressions.  Also, a Term
Expression can be reduced to a Term Term with a pair of parentheses, which
allows the operators, `-', `+', `*', and `/' can appear recursively in a
Term Expression.  This also means that `(' and `)' operators have higher
operation priority than other operators.

\subsection{Arguments}
Arguments play a role in passing data from Facts to Job, by converting Facts
into matrices so that the Job computes the matrices by the algorithm
described in the Job.

\subsubsection{Argument Candidate}
\begin{lstlisting}
arg_cand
	: IDENTIFIER
	| IDENTIFIER `(' arg_list `)'
	| VARIABLE
	| `_'
	| NUMBER
	| STRING_LITERAL
	;
\end{lstlisting}

Argument Candidate is an Identifier, a Variable, an Anonymous
Variable, a Number, or a String.  An Identifier can have one
or more arguments within a pair of parentheses or no arguments.
This arguments again consist of Argument Candidates, which
allows a recursive form of argument definition.  For instance, 
$com(monitor, board(cpu, ram(4, 4)), P)$ is a valid form
of a Term declaration.

\subsubsection{Argument List}
\begin{lstlisting}
arg_list
	: arg_cand
	| arg_list `,' arg_cand
	;
\end{lstlisting}

Argument List is used for 1. A Fact declaration that calls a Job
2. A Term that has arguments 3. A Job definition.  Sharing the
same type of argument list for three different rules are possible
because there is not type and variable declaration in MIPL.  Thus,
a Job definition and a Job-calling Fact basically have the same
argument list.  There are a few diffences that will be checked
semantically at compile time and dynamically at runtime.  For example,
current implementation of MIPL does not support passing of nested
parameters so these errors are checked by Semantic Checker, which may
be eased later when MIPL is extended to support nested parameter passing
without changing its grammar.  Also, MIPL's Job definitions allows
variable numbers of return values dynamically, the generated program
checks if the numbers of return values from Job and the numbers of
Fact names are matched.  Otherwise, it fails to run.

\subsection{Job}

\begin{lstlisting}
job
	: IDENTIFIER `(' arg_list `)' `{' stmt_list `}'
	;
\end{lstlisting}

\label{Job_Section}
Job is MIPL's basic operation that provides matrix operations.
A Job definition denotes a number of arguments and a set of Job
Statements.  At runtime, a compiled Job is distributed over
a MapReduce clusters, computed, and delivered to the user. For
example, when a user loads two matrices and calls a Job giving those
matrices, the matrices are split into several smaller matrices,
distributed to MapReduce clusters, and computed.


\subsection{Job Statement}

\begin{lstlisting}
stmt
	: selection_stmt
	| compound_stmt
	| return_stmt
	| expr_stmt
	| iteration_stmt
	;
\end{lstlisting}

Job Statement is a sentence in a Job.  There are five types of
Job Statement: Job Selection Statement, Job Compound Statement,
Job Return Statement, Job Expression Statement, and Job Iteration
Statement.  Each of these will be explained in the following
sections.

\subsubsection{Job Statement List}

\begin{lstlisting}
stmt_list
	: stmt
	| stmt_list stmt
	;
\end{lstlisting}

Job Statement List is a set of Job Statement, used in Job
declarations and Job Compound Statement.


\subsubsection{Job Compound Statement}

\begin{lstlisting}
compound_stmt
	: `{' `}'
	| `{' stmt_list `}'
	;
\end{lstlisting}

Job Compound Statement is a Job Statement, which includes
zero or more Job Statements, embraced by a pair of curly
brackets.

\subsubsection{Job Return Statement}

\begin{lstlisting}
return_stmt
	: `@' expr `.'
	;

\end{lstlisting}

Job Return Statement is a sentence that returns a matrix.  Since
Job is likely executed on MapReduce clusters (unless configured
so or the matrix size is smaller than configured threshold), Job
Return Statement fetches the matrix.  The most interesting part
in MIPL with regard to Job Return Statement is a Job can contain
more than on Job Return Statement for returning values more than
one.  Accordingly, as a Job can contain a number of Job Selection
Statements and Job Iterative Statements, the combination of those
allows a Job to return variable numbers of return values. This is
possible because Job Return Statement does not ``return" immediately,
when its program counter meets Job Return Statement.  Instead, a
MIPL program keeps being executed passing that Job Return Statement.
For example, below MIPL program returns three matrix values.  If
the given number of names for return values are not matched to the
number of values the actual Job returns, MIPL reports an error.

\begin{lstlisting}
I = 3;
[a, b, c] = job1(matrix1, matrix2, I).

job1(A, B, NumRepeat) {
    while (NumRepeat > 0) {
       A *= B.
       @A.
       I = I - 1. 
    }
}
\end{lstlisting}

Because Job Return Statement does not ``return" immediately,
there's no acceptable Job Return Statement like $@.$, which some
languages provide to flow control such as ``return;" in C.  The
return operator $@$ is designed to deliver a matrix value from
MapReduce clusters to the user.  When a user want to quit the Job
in the mid of the Job, the user should use Job Control Statements
such as If Statement to do so.


\subsubsection{Job Expression Statement}

\begin{lstlisting}
expr_stmt
	: expr `.'
	;
\end{lstlisting}

Job Expression Statement is a Job Statement that includes a Job
Expression.  This allows users use Job Expressions in a Job.

\subsubsection{Job Selection Statement}

\begin{lstlisting}
selection_stmt
	: IF `(' bool_expr `)' stmt
	| IF `(' bool_expr `)' stmt ELSE stmt
	;
\end{lstlisting}

Job Selection Statement is a conditional control Job Statement,
which checks the value of given Job Boolean Expression and executes
the statements accordingly.  If the value of the Job Expression is
true, the first Job Statement will be executed.  If the value of
the expression is false and the ELSE statement is provided, this
statement will be executed.  The IF ELSE syntax is ambiguous,
however, by Yacc's default behavior, reduce precedes shift, which
results in that the ELSE is associated with closer IF.

\subsubsection{Job Iteration Statement}

\begin{lstlisting}
iteration_stmt
	: WHILE `(' bool_expr `)' stmt
	| DO stmt WHILE `(' bool_expr `)' `.'
	;
\end{lstlisting}

Job Iteration Statement is a statement, that repeatedly executes
the given Job Statement according to the value of Job Expression.

WHILE statement executes the given Job Statement while the Job
Boolean Expression's value is true.  DO WHILE statement executes the
Job Statement once first, and then executes the Job Statement repeatedly
while the Job Boolean Expression's value is true.


\subsection{Job Expression}

\begin{lstlisting}
expr
	: additive_expr
	| VARIABLE assign_op assign_expr
	;
\end{lstlisting}

\label{Expression_Section}
Job Expression is a grammatical unit that conveys a numeric value,
which includes a matrix or a number.  Whether a Job Expression
contains a matrix or a number is decided dynamically at runtime,
as well as how big is the matrix, since MIPL is dynamic typed.

Job Expressions assigns a numberic value to a Variable contained
at the left-hand side.  The value of Job Expression is the value
newly assigned to the Variable.  This may relays multiple times,
for example, $Variable1 = Variable2 = Variable3 = 3.$.


\subsubsection{Job Assignment Operator}

\begin{lstlisting}
assign_op
	: `='
	| LARROW_OP
	| MUL_ASSIGN
	| DIV_ASSIGN
	| MOD_ASSIGN
	| ADD_ASSIGN
	| SUB_ASSIGN
	;
\end{lstlisting}

Job Assignment Operator has seven types.  1. `=' and ``$<-$" are used
for Assignment.  2. ``*=" is Muliplication Assignment Operator.  3. 
``/=" is Division Assignment Operator.  4. ``\%=" is Modular Assignment
Operator.  5. ``+=" is Addition Assignment Operator.  6. ``-=" is
Subtraction Assignment Operator.  Each Assignment Operators computes
the value of the operation using the left-hand side value and the
right-hand side value and assigns the value to the left-hand side
Variable.


%----------------------------------------------------------YOUNGHOON}

%----------------------------------------------------------AKSHAI{
\subsubsection{Job Additive Expression}

The character sequence `+' and `-' mean addition and subtraction, 
respectively. These operators in Additive expressions, or additive\_expr, 
also associate left to right and have lower precedence than the 
multiplicative expressions, termed multiplicative\_expr, described next.

\begin{lstlisting}
additive_expr
	: multiplicative_expr
	| additive_expr `+' multiplicative_expr
	| additive_expr `-' multiplicative_expr
	;
\end{lstlisting}

Given two multiplicative expressions, connected by an additive operator, 
the expression evaluates to the result of applying the operator to the
operands. However, this depends on the type of the operands, which can
range from integer or doubles to matrices. In the case of the latter,
the evaluation of the expression results in a matrix, formed by the 
application of the operation on the multiplicative expressions. Operands 
are converted (implicitly casted) to the appropriate type to perform the
operation. For instance, the addition of a scalar to the a matrix, results in 
the scalar being converted to a appropriate matrix and the resulting matrix
be applied to the operation. The `+' and the `-' operators can be applied 
to arithmetic and matrix types.

\subsubsection{Job Multiplicative Expression}

The character sequence `*' and `/' mean multiplication and division, 
respectively. The sequence `\%' represents the modulus operation. That
is, the remainder after the division of the right operand into the left
operand. These operators in Multiplicative expressions, or 
multiplicative\_expr, associate left to right and have lower precedence 
than unary expressions.

\begin{lstlisting}
multiplicative_expr
	: unary_expr
	| multiplicative_expr `*' unary_expr
	| multiplicative_expr `/' unary_expr
	| multiplicative_expr `%' unary_expr
	;
\end{lstlisting}

As with the additive expressions, the operators are applicable to types
where the mathematical equivalent is valid. For the case of multiplying
matrices, the requirement that the number of columns of the left operand 
be equal to the number of rows of the right operand. The result of the
evaluation of the operation is contained within the set of basic data 
types. The multiplication of a matrix expression with another results in 
a matrix expression. As with the additive expressions, there is still 
automatic type casting and the operands may be converted to match the
the more general operand. 

\subsubsection{Job Unary Expression}
  
A unary expression contains the unary operators `+' for positive and `-' 
for negative. The `+' operator when applied to an arithmetic type does
not change the value of the type. The `-' operator when applied to an
arithmetic type, produces the negative of its operand. The operators, 
unlike with the additive and multiplicative expressions, may only be
applied to expressions that produce an arithmetic type.


\begin{lstlisting}
unary_expr
	: postfix_expr
	| `+' unary_expr
	| `-' unary_expr
	;
\end{lstlisting}

\subsubsection{Job PostFix Expression}

A postfix expression is either a primary expression, an matrix access or 
a Job call.

\begin{lstlisting}
postfix_expr
	: primary_expr
	| VARIABLE `[' array_idx_list `]' `[' array_idx_list `]'
	| IDENTIFIER `(' `)'
	| IDENTIFIER `(' argument_expr_list `)'
	;
\end{lstlisting}

A VARIABLE is like an IDENTIFIER but it begins with an uppercase letter,
followed by lowercase or uppercase alphabets or underscore. A VARIABLE
followed by two `[' and `]' is a matrix access. The matrix is accessed
by subscripts, also known as the array index list, described in a later
section. The subscripts correspond exactly to the two dimensional 
interpretation of the matrix, where the the subscript within the first 
set of square brackets refers to the row of the matrix while the second
subscript refers to the corresponding pressure. The VARIABLE must refer 
to matrix type. Using array index lists, any subset of the matrix can be
obtained. The result of this postfix expression can be a single value of
the type of the matrix or any subset of the matrix.

An IDENTIFIER followed by a set of paranthesis `(' and `)' is a Job
invocation. A Job is defined according to \ref{Job_Section}. Only a defined
Job may be invoked using the IDENTIFIER referring to the Job name,
followed by `(' and `)', where the parantheses enclose arguments passed
to the Job. If there were no arguments defined for the Job, the
parantheses do not include anything and if there were arguments defined, 
arguments that match the number of arguments in the Job definition, must
be provided. These arguments are provided using the argument\_expr\_list 
defined below. The arguments passed are by value. That is, the arguments 
are copied and the copies are passed to the Job being invoked.

\subsubsection{Job Primary Expression}

A Job primary expression is the most basic type of expression. In any
expression, a primary expression has the highest precedence.

\begin{lstlisting}
primary_expr
	: IDENTIFIER
	| VARIABLE
	| NUMBER
	| `(' expr `)'
	;
\end{lstlisting}

An IDENTIFIER is a primary expression. An IDENTIFIER need not be declared
as MIPL is dynamically and weakly typed. Any token matching the description
of an IDENTIFIER, starting with a lowercase letter followed by uppercase and
underscore characters, is recognized as one. An IDENTIFIER that is not 
referring to a Job, is a primitive type such as an integer or a double.

A VARIABLE is also a primary expression. A VARIABLE is used to denote complex 
data types such as matrices in order to distinguish them from IDENTIFIERS.

A NUMBER refers to a the decimal representation of a number and is also a 
primary expression. Scientific notation is also supported, following the 
E-notation. $10^{x}$ in scientific notation is simply written with either an
`e' or an `E' followed by x.

Finally, an expression enclosed with parantheses is also a primary expression 
and the value of this expression is the same as if the parantheses did not 
exist.

\subsubsection{Job Array Index List}

An array index list can be used to access the relevant portions of a matrix. 
The relevant portions of a matrix are referred to using array index elements, 
described below. The array index elements are evaluated left to right.

\begin{lstlisting}
array_idx_list
	: array_idx_elmt
	| array_idx_list `,' array_idx_elmt
	;
\end{lstlisting}

Using the list of array indices, any relevant, valid portion of a matrix may
be accessed. For instance, given a 5 x 7 matrix A, A[2$\sim$4,6$\sim$][1] produces the
subset of the matrix A, a 5 x 1 result, consisting of its third, fourth, 
fifth and seventh rows and its second column.

\subsubsection{Job Array Index Element}

An array index element is used to access a matrix. It consists of either 
the character `$\sim$' representing all valid indices or any combination of placing
a NUMBER to either side of the character. 

\begin{lstlisting}
array_idx_elmt
	: `\~'
	| `~' NUMBER
	| NUMBER
	| NUMBER `~'
	| NUMBER `~' NUMBER
	;
\end{lstlisting}

NUMBER here refers to any integer that denotes a valid index for the 
matrix, referring to either its $i^{th}$ row or column. Rows and columns are 
referred to starting at 0. If a NUMBER is not specified at either 
the left or the right of the `$\sim$' character, it defaults to the extreme 
of the matrix subscript. In other words, the smallest valid subscript in 
the case of the left, which is 0, and the largest valid subscript in the 
case of the right, which is the total number of rows or columns depending
on, which is being accessed.

\subsubsection{Job Argument Expression List}

An argument expression list represents the various arguments that may be
passed to a Job invocation. 

\begin{lstlisting}
argument_expr_list
	: expr
	| argument_expr_list `,' expr
	;
\end{lstlisting}

These arguments are evaluated left to right and can include any assignment 
expression as described above in \ref{Expression_Section}.

\subsection{Job Boolean Expression}

Job Boolean Expression is a basic Expression that can be evaluated as
true or false.  Job Selection Statement and Job Iteration Statement
contains Job Boolean Expression in order to determine whether to proceed
or how many times to repeat.

The character sequence OR\_OP refers to the sequence ``\textbardbl", which  
denotes the logical OR operator. The logical AND expressions that are 
separated by the logical OR operator associate left. The next section 
details how the logical AND expressions, logical\_and\_expr, which have 
higher precedence than the logical OR expression, are evaluated. 

\begin{lstlisting}
bool_expr
	: logical_and_expr
	| bool_expr OR_OP logical_and_expr
	;
\end{lstlisting}

Given a binary OR\_OP, the Job Boolean Expression evaluates to true 
if either of the nested bool\_expr or the logical\_and\_expr evaluates
to true, and evaluates to false if both of the bool\_expr or
logical\_and\_expr evaluate to false, The order of evaluation is left
to right, also known as the ``short circuit" evaluation, whereby
the logical\_and\_expr on the right of the OR\_OP is evaluated if
and only if the logical\_and\_expr on the left of the OR\_OP 
evaluated to false. 

\subsubsection{Job Logical AND Expression}

The character sequence AND\_OP refers to the sequence ``\&\&", which 
denotes the logical AND operator. The equality expressions that are 
separated by the logical OR operator associate left. The next section 
details how equality expressions, equality\_expr, which have higher 
precedence than the logical OR expression, are evaluated. 

\begin{lstlisting}
logical_and_expr
	: equality_expr
	| logical_and_expr AND_OP equality_expr
	;
\end{lstlisting}

Given a binary AND\_OP, the Logical AND expression evaluates to true,
if both of the logical\_and\_expr evaluate to true and evaluates to false,
if either of the logical\_and\_expr evaluate to false. 
The order of evaluation is again left to right, whereby the 
equality\_expr on the right of the AND\_OP is evaluated if and only 
if the equality\_expr on the left of the OR\_OP evaluated to true.

\subsubsection{Job Equality Expression}

The character sequence EQ\_OP refers to the sequence ``==" and the 
character sequence NE\_OP refers to the sequence ``!=". These operators, 
equal to and not equal to, respectively, cause the expression to 
evaluate to false and true.  These operators that separate the
relational expressions, relational\_expr, associate left. The
operators EQ\_OP and NE\_OP have lower precedence than the 
operators that constitute the relational expressions, described in the 
next section. 

\begin{lstlisting}
equality_expr
	: relational_expr
	| expr EQ_OP expr
	| expr NE_OP expr
	| equality_expr EQ_OP relational_expr
	| equality_expr NE_OP relational_expr
	;
\end{lstlisting}

Given two relational expressions, connected by a EQ\_OP or a NE\_OP, 
Job Expression or Job Equality Expression evaluates to true, 
if and only if the left and the right Job Expressions both evaluate
to the same value in the case of a EQ\_OP and to different values in
the case of a NE\_OP.  Otherwise, the equality expression evaluates
to false.

\subsubsection{Job Relational Expression}

The character sequence LE\_OP refers to the sequence ``$<=$", for less 
than or equal to and GE\_OP refers to the sequence ``$>=$", for greater 
than or equal to. The sequences `$<$' and `$>$' mean exactly the same as 
their mathematical counterpart relations. These operators also associate 
left to right and have lower precedence than the operators in the additive 
expression type, additive\_expr, described in the following section. The 
evaluation of a relational expression is once again a truth value, 
represented by the false and true. 

\begin{lstlisting}
relational_expr
	: boolvalue_expr
	| expr `<' expr
	| expr `>' expr
	| expr LE_OP expr
	| expr GE_OP expr
	;
\end{lstlisting}

Given two Job Expressions, connected by the above mentioned operators, 
Job Relational Expression evalutes to true if the mathematical relation
represented by the operation is satisfied. Otherwise, Job Relational
Expression evaluates to false. 


\subsubsection{Job BooleanValue Expression}

\begin{lstlisting}
boolvalue_expr
	: TRUE
	| FALSE
	| '(' bool_expr ')'
	;
\end{lstlisting}

The character sequences TRUE and FALSE refer to the sequences ``true"
and ``false" respectively.  Job BooleanValue Expression can be expanded
to a nested Job Boolean Expression embraced with a pare of parentheses.


%----------------------------------------------------------AKSHAI}
\section{Operators}
MIPL has various operators to support matrix operation.

\subsection{Operator $+$}
Addition or unary plus. A+B adds A and B. A and B must have the same size, unless one is a scalar. A scalar can be added to a matrix of any size.

\subsection{Operator $-$}
Subtraction or unary minus. A–B subtracts B from A. A and B must have the same size, unless one is a scalar. A scalar can be subtracted from a matrix of any size.

\subsection{Operator $*$}
Matrix multiplication. C = A $*$ B is the linear algebraic product of the matrices A and B. More precisely,

$C(i,j) = \displaystyle\sum\limits_{k=1}^n A(i,k)B(k,j).$

For nonscalar A and B, the number of columns of A must equal the number of rows of B. A scalar can multiply a matrix of any size.

\subsection{Operator $.*$}
Array multiplication. A.∗B is the element-by-element product of the arrays A and B. A and B must have the same size, unless one of them is a scalar.

\subsection{Operator $/$}
Slash or matrix right division. B/A is roughly the same as B $∗$ inv(A). More precisely, B/A = (A'\textbackslash B')'. See \textbackslash.

\subsection{Operator $./$}
Array right division. A./B is the matrix with elements A(i,j)/B(i,j). A and B must have the same size, unless one of them is a scalar.

\subsection{Operator \textbackslash}
Backslash or matrix left division. If A is a square matrix, A\textbackslash B is roughly the same as inv(A) ∗ B, except it is computed in a different way. If A is an n-by-n matrix and B is a column vector with n components, or a matrix with several such columns, then X = A\textbackslash B is the solution to the equation AX = B computed by Gaussian elimination. A warning message prints if A is badly scaled or nearly singular.
If A is an m-by-n matrix with m ~= n and B is a column vector with m components, or a matrix with several such columns, then X = A\textbackslash B is the solution in the least squares sense to the under- or overdetermined system of equations AX = B. The effective rank, k, of A, is determined from the QR decomposition with pivoting. A solution X is computed which has at most k nonzero components per column.

\subsection{Operator .\textbackslash}
Array left division. A.\textbackslash B is the matrix with elements B(i,j)/A(i,j). A and B must have the same size, unless one of them is a scalar.

\subsection{Operator \^{}}
Matrix power. X\^{}p is X to the power p, if p is a scalar. If p is an integer, the power is computed by repeated multiplication. If the integer is negative, X is inverted first. For other values of p, the calculation involves eigenvalues and eigenvectors, such that if [V,D] = eig(X), then X\^{}p = V∗D.\^{}p/V.
If x is a scalar and P is a matrix, x\^{}P is x raised to the matrix power P using eigenvalues and eigenvectors. X\^{}P, where X and P are both matrices, is an error.

\subsection{Operator .\^{}}
Array power. A .\^{} B is the matrix with elements A(i,j) to the B(i,j) power. A and B must have the same size, unless one of them is a scalar.

\section{Built-in Terms}
Functions here

\subsection{eye()}
Function eye() returns the identity matrix.
\begin{lstlisting}
Y = eye(n)
Y = eye(m,n)
\end{lstlisting}

Y = eye(n) returns the n-by-n identity matrix. Y = eye(m,n) or eye([m n]) returns an m-by-n matrix with 1’s on the diagonal and 0’s elsewhere.

\subsection{ones()}
Function ones() creates an array of all ones
\begin{lstlisting}
Y = ones(n)
Y = ones(m,n)
Y = ones([m n])
Y = ones(d1,d2,d3...)
Y = ones([d1 d2 d3...])
\end{lstlisting}

Y = ones(n) returns an n-by-n matrix of 1s. An error message appears if n is not a scalar. Y = ones(m,n) or Y = ones([m n]) returns an m-by-n matrix of ones. Y = ones(d1,d2,d3...) or Y = ones([d1 d2 d3...]) returns an array of 1s with dimensions d1-by-d2-by-d3-by-....

\subsection{rand()}
Function rand() generates arrays of random numbers whose elements are uniformly distributed in the interval (0,1).
\begin{lstlisting}
Y = rand(n)
Y = rand(m,n)
Y = rand([m n])
Y = rand(m,n,p,...)
Y = rand([m n p...])
rand
\end{lstlisting}

Y = rand(n) returns an n-by-n matrix of random entries. An error message appears if n is not a scalar. Y = rand(m,n) or Y = rand([m n]) returns an m-by-n matrix of random entries. Y = rand(m,n,p,...) or Y = rand([m n p...]) generates random arrays. 
rand, by itself, returns a scalar whose value changes each time it’s referenced.

\subsection{cat()}
Function cat() concatenates arrays.
\begin{lstlisting}
C = cat(dim,A,B)
C = cat(dim,A1,A2,A3,A4...)
\end{lstlisting}

C = cat(dim,A,B) concatenates the arrays A and B along dim. C = cat(dim,A1,A2,A3,A4,...) concatenates all the input arrays (A1, A2, A3, A4, and so on) along dim. cat(2,A,B) is the same as [A,B] and cat(1,A,B) is the same as [A;B].

\subsection{eig()}
Function eig() returns a vector of the eigenvalues of matrix.
\begin{lstlisting}
d = eig(A)
d = eig(A,B)
\end{lstlisting}

d = eig(A) returns a vector of the eigenvalues of matrix A. d = eig(A,B) returns a vector containing the generalized eigenvalues, if A and B are square matrices.

\subsection{max()}
Function max() returns the largest elements along different dimensions of an array.
\begin{lstlisting}
C = max(A)
C = max(A,B)
C = max(A,[],dim)
[C,I] = max(...)
\end{lstlisting}

If A is a vector, max(A) returns the largest element in A. If A is a matrix, max(A) treats the columns of A as vectors, returning a row vector containing the maximum element from each column. If A is a multidimensional array, max(A) treats the values along the first non-singleton dimension as vectors, returning the maximum value of each vector.

C = max(A,B) returns an array the same size as A and B with the largest elements taken from A or B.

C = max(A,[],dim) returns the largest elements along the dimension of A specified by scalar dim. For example, max(A,[],1) produces the maximum values along the first dimension (the rows) of A.

[C,I] = max(...) finds the indices of the maximum values of A, and returns them in output vector I. If there are several identical maximum values, the index of the first one found is returned.

\subsection{mean()}
Function mean() returns the mean values of the elements along different dimensions of an array.
\begin{lstlisting}
M = mean(A)
M = mean(A,dim)
\end{lstlisting}

If A is a vector, mean(A) returns the mean value of A. If A is a matrix, mean(A) treats the columns of A as vectors, returning a row
vector of mean values. If A is a multidimensional array, mean(A) treats the values along the first non-singleton dimension as vectors, returning an array of mean values.

M = mean(A,dim) returns the mean values for elements along the dimension of A specified by scalar dim.

\subsection{min()}
Function min() returns the smallest elements along different dimensions of an array.
\begin{lstlisting}
C = min(A)
C = min(A,B)
C = min(A,[],dim)
[C,I] = min(...)
\end{lstlisting}

If A is a vector, min(A) returns the smallest element in A. If A is a matrix, min(A) treats the columns of A as vectors, returning a row vector containing the minimum element from each column. If A is a multidimensional array, min operates along the first nonsingleton dimension.

C = min(A,B) returns an array the same size as A and B with the smallest elements taken from A or B.

C = min(A,[],dim) returns the smallest elements along the dimension of A specified by scalar dim. For example, min(A,[],1) produces the minimum values along the first dimension (the rows) of A.

[C,I] = min(...) finds the indices of the minimum values of A, and returns them in output vector I. If there are several identical minimum values, the index of the first one found is returned.

\subsection{sum()}
Function sum() returns sums along different dimensions of an array.
\begin{lstlisting}
B = sum(A)
B = sum(A,dim)
\end{lstlisting}

If A is a vector, sum(A) returns the sum of the elements. If A is a matrix, sum(A) treats the columns of A as vectors, returning a row vector of the sums of each column. If A is a multidimensional array, sum(A) treats the values along the first non-singleton dimension as vectors, returning an array of row vectors.

B = sum(A,dim) sums along the dimension of A specified by scalar dim.

\subsection{abs()}
Function abs() returns the absolute value and complex magnitude.
\begin{lstlisting}
Y = abs(X)
\end{lstlisting}

abs(X) returns the absolute value, X, for each element of X. If X is complex, abs(X) returns the complex modulus (magnitude):

abs(X) = $\displaystyle\sqrt{real(X)^2 + imag(X)^2}$

\subsection{Syntax subsection}

\section*{Appendix - Grammar}

MIPL's full grammar is here. MIPL's Yacc grammar has only one shift/reduce conflict, which C language also has, without using operator associativity declarations.

\lstinputlisting{../../build/mipl.grammar}
%\input{../../build/mipl_grammar.tex}
%\lstinputlisting{tablified_grammar}

% Appendix
%\appendix
%\section*{APPENDIX}
%\setcounter{section}{1}
%In this appendix, we measure

%\appendixhead{ZHOU}

% Acknowledgments
%\begin{acks}
%The authors would like to thank Dr. Maura Turolla of Telecom
%\end{acks}

% Bibliography
%\bibliographystyle{acmsmall}
%\bibliography{reference_manual_ref}

% History dates
%\received{February 2007}{March 2009}{June 2009}

% Electronic Appendix
%\elecappendix

\medskip

%\section{This is an example of Appendix section head}

\end{document}
