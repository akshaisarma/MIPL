% acmsmall-sample.tex, dated 4th Nov. 2011
% This is a sample file for ACM small trim journals
%
% Compilation using 'acmsmall.cls' - version 1.2, Aptara Inc.
% (c) 2010 Association for Computing Machinery (ACM)
%
% Questions/Suggestions/Feedback should be addressed to => "acmtexsupport@aptaracorp.com".
% Users can also go through the FAQs available on the journal's submission webpage.
%
% Steps to compile: latex, bibtex, latex latex
%
% For tracking purposes => this is v1.2 - Nov. 2011

\documentclass[prodmode,acmtecs]{acmsmall}

% Package to generate and customize Algorithm as per ACM style
\usepackage[ruled]{algorithm2e}
\usepackage{listings}
\usepackage{longtable}
\renewcommand{\algorithmcfname}{ALGORITHM}
\SetAlFnt{\large}
\SetAlCapFnt{\large}
\SetAlCapNameFnt{\large}
\SetAlCapHSkip{10pt}
\IncMargin{-\parindent}

% Metadata Information
\acmVolume{1}
\acmNumber{1}
\acmArticle{1}
\acmYear{2012}
\acmMonth{3}

% Document starts
\begin{document}

% Page heads
%\markboth{Young Hoon et al.}{MIPL Reference Manual}

% Title portion
\title{{MIPL: Mining Integrated Programming Language\\
Language Reference Manual}}
\author{Project Manager: Younghoon Jeon $<yj2231@columbia.edu>$\\
System Architect: Young Hoon Jung $<yj2244@columbia.edu>$\\
Language Expert: Jinhyung Park $<jp2105@columbia.edu>$\\
System Integrator: Daniel Wonjoon Song $<dws2127@columbia.edu>$\\
System Validation: Akshai Sarma $<as4107@columbia.edu>$
%\affil{Columbia University}
}

\begin{abstract}
Abstraction here.
\end{abstract}

%\category{C.2.2}{Computer-Communication Networks}{Network Protocols}

%\terms{Design, Algorithms, Performance}

%\keywords{Wireless sensor networks, media access control,
%multi-channel, radio interference, time synchronization}

%\acmformat{Zhou, G., Wu, Y., Yan, T., He, T., Huang, C., Stankovic,
%J. A., and Abdelzaher, T. F.  2010. A multifrequency MAC specially
%designed for  wireless sensor network applications.}

%\begin{bottomstuff}
%This work is supported by the National Science Foundation, under
%\end{bottomstuff}

\maketitle


\lstset{frame=single}

\section{Introduction}

Introduction here.

Item sample.
\begin{itemize}
\item item1 To the best of our knowledge, the MMSN protocol is the first
\item item2 Instead of using pairwise RTS/CTS frequency negotiation
\end{itemize}

% Head 1
\section{Lexical conventions}
MIPL has six kinds of tokens: identifiers, variables, numbers, strings,
expression operators, and other separators.  In general blanks, tabs,
newlines, and comments as described below are ignored except as they
serve to separate tokens. At least one of these characters is required
to separate otherwise adjacent identifiers, constants, and certain
operatorpairs.  If the input stream has been parsed into tokens up
to a given character, the next token is taken to include the longest
string of characters which could possibly constitute a token.

% Head 2
\subsection{Comments}

MIPL uses shell script-like comments, which begins with the character
\# and terminates at the end of the line, separated by the newline character.

% Head 3
\subsection{Identifiers}

An identifier is a sequence of letters that begins with lower case alphabets.
Upper and lower case letters are considered different.   Identifiers are
served for use as the name of Terms, the basic block of MIPL syntax.

\subsection{Variables}

A variable is a sequence of letters that begins with upper case alphabets
or the underscore character, \_, which means that this variable will not
be tracked.  Upper and lower case letters in the variable names are
considered different. 

\subsection{Numbers}

A number in MIPL is a floating number.  A number consists of an integer
part, a decimal point, a fraction part, an e, and an optionally signed integer
exponent. The integer and fraction parts both consist of a sequence of digits.
Either the integer part or the fraction
part (not both) may be missing; either the decimal point or the
e and the exponent (not both) may be missing.
Every floating constant is taken to be doubleprecision.

\subsection{Strings}

A string is a sequence of characters surrounded by double quotes or single
quotes.
A string has the type arrayofcharacters
(see below) and refers to an area of storage initialized with the given
characters. The compiler places a null byte ( \\0 ) at the end of each
string so that programs which scan the string can find its end. In a
string, the character ..  " ..  must be preceded by a ..\.. ; in
addition, the same escapes as described for character constants may be used.
NEED FIX

\subsection{Expression Operators}
Expression Operators will be explained in Built-in Operators and Jobs section.

\section{Data Types}

Data Types here.

\section{Syntax}

Syntax here

%----------------------------------------------------------JINHYUNG{
\subsection{Program}

A program looks like this:

\begin{lstlisting}
program
	: commands
	;
\end{lstlisting}


\subsection{Commands}

\begin{lstlisting}
commands
	: command commands
	| command
	;
\end{lstlisting}


\subsection{Command}

\begin{lstlisting}
command
	: fact
	| query
	| rule
	| job
	;
\end{lstlisting}

%----------------------------------------------------------JINHYUNG}
%----------------------------------------------------------YOUNGHOON{

\subsection{Term Expression}
\begin{lstlisting}
term_expr
	: term_expr `+' term_fact
	| term_expr `-' term_fact
	| term_fact
	;
\end{lstlisting}

Term Expression is an expression which belongs to a Term.  Term 
Expressions can consist of binary operators `+' and `-' along with Term
Factors.  These two operators left-associate Term Facts so that Term
Factors within a Term Expression can be computed with a left priority.

Term Expression, Term Factor, and Term Term are basic blocks that
consist Term Expression.  So these three rules can be applied within
Term Expression, by the definition of MIPL grammar.

\subsubsection{Term Factor}

\begin{lstlisting}
wkeowekowk
\end{lstlisting}
\begin{lstlisting}
term_fact
	: term_fact `*' term_term
	| term_fact `/' term_term
	| term_term
	;
\end{lstlisting}

Term Factor is an expression which belongs to a Term Expression.  Term 
Factors can consist of binary operators `*' and `/' along with Term
Term.  These two operators left-associate Term Terms so that Term
Terms within a Term Factor can be computed with a left priority. Like,
mathematical notations, operators `*' and `/' have higher priority than
operators `+' and `-' since Term Facts are reduced 


\subsubsection{Term Term}
\begin{lstlisting}
term_term
	: VARIABLE
	| NUMBER
	| `(' term_expr `)'
	;
\end{lstlisting}

Term Term is a terminal expression of Term Expression and its derivables,
belonging to a Term Factor.  Term Terms can consist of a Variable or a
Number, which serve as the basic blocks of Term Expressions.  Also, a Term
Expression can be reduced to a Term Term with a pair of parentheses, which
allows the operators, `-', `+', `*', and `/' can appear recursively in a
Term Expression.  This also means that `(' and `)' operators have higher
operation priority than other operators.

\subsection{Arguments}
Arguments play a role in passing data from Facts to Job, by converting Facts
into matrices so that the Job computes the matrices by the algorithm
described in the Job.

\subsubsection{Argument Candidate}
\begin{lstlisting}
arg_cand
	: IDENTIFIER
	| IDENTIFIER `(' arg_list `)'
	| VARIABLE
	| `_'
	| NUMBER
	| STRING_LITERAL
	;
\end{lstlisting}

Argument Candidate is an Identifier, a Variable, an Anonymous
Variable, a Number, or a String.  An Identifier can have one
or more arguments within a pair of parentheses or no arguments.
This arguments again consist of Argument Candidates, which
allows a recursive form of argument definition.  For instance, 
$com(monitor, board(cpu, ram(4, 4)), P)$ is a valid form
of a Term declaration.

\subsubsection{Argument List}
\begin{lstlisting}
arg_list
	: arg_cand
	| arg_list `,' arg_cand
	;
\end{lstlisting}

Argument List is used for 1. A Fact declaration that calls a Job
2. A Term that has arguments 3. A Job definition.  Sharing the
same type of argument list for three different rules are possible
because there is not type and variable declaration in MIPL.  Thus,
a Job definition and a Job-calling Fact basically have the same
argument list.  There are a few diffences that will be checked
semantically at compile time and dynamically at runtime.  For example,
current implementation of MIPL does not support passing of nested
parameters so these errors are checked by Semantic Checker, which may
be eased later when MIPL is extended to support nested parameter passing
without changing its grammar.  Also, MIPL's Job definitions allows
variable numbers of return values dynamically, the generated program
checks if the numbers of return values from Job and the numbers of
Fact names are matched.  Otherwise, it fails to run.

\subsection{Job}

\begin{lstlisting}
job
	: IDENTIFIER `(' arg_list `)' `{' stmt_list `}'
	;
\end{lstlisting}

Job is MIPL's basic operation that provides matrix operations.
A Job definition denotes a number of arguments and a set of Job
Statements.  At runtime, a compiled Job is distributed over
a MapReduce clusters, computed, and delivered to the user. For
example, when a user loads two matrices and calls a Job giving those
matrices, the matrices are split into several smaller matrices,
distributed to MapReduce clusters, and computed.


\subsection{Job Statement}

\begin{lstlisting}
stmt
	: selection_stmt
	| compound_stmt
	| return_stmt
	| expr_stmt
	| iteration_stmt
	;
\end{lstlisting}

Job Statement is a sentence in a Job.  There are five types of
Job Statement: Job Selection Statement, Job Compound Statement,
Job Return Statement, Job Expression Statement, and Job Iteration
Statement.  Each of these will be explained in the following
sections.

\subsubsection{Job Statement List}

\begin{lstlisting}
stmt_list
	: stmt
	| stmt_list stmt
	;
\end{lstlisting}

Job Statement List is a set of Job Statement, used in Job
declarations and Job Compound Statement.


\subsubsection{Job Compound Statement}

\begin{lstlisting}
compound_stmt
	: `{' `}'
	| `{' stmt_list `}'
	;
\end{lstlisting}

Job Compound Statement is a Job Statement, which includes
zero or more Job Statements, embraced by a pair of curly
brackets.

\subsubsection{Job Return Statement}

\begin{lstlisting}
return_stmt
	: `@' expr `.'
	;

\end{lstlisting}

Job Return Statement is a sentence that returns a matrix.  Since
Job is likely executed on MapReduce clusters (unless configured
so or the matrix size is smaller than configured threshold), Job
Return Statement fetches the matrix.

There's no acceptable Job Return Statement like $@.$.  The
return operator $@$ is designed to deliver a matrix value from
MapReduce clusters to the user.  When a user want to quit the Job
in the mid of the Job, the user should use Job Control Statements
such as If Statement to do so.


\subsection{Job Expression Statement}

Probably should make all the expressions below subsubsections instead of subsections.

\begin{lstlisting}
expr_stmt
	: expr `.'
	;
\end{lstlisting}


\subsubsection{Job Selection Statement}
whatthe\\
\begin{lstlisting}
selection_stmt
	: IF `(' expr `)' stmt
	| IF `(' expr `)' stmt ELSE stmt
	;
\end{lstlisting}


\subsubsection{Job Iteration Statement}
no\\
\begin{lstlisting}
iteration_stmt
	: WHILE `(' expr `)' stmt
	| DO stmt WHILE `(' expr `)' `.'
	;
\end{lstlisting}


\subsubsection{Job Expression}

\begin{lstlisting}
expr
	: assign_expr
	;
\end{lstlisting}


\subsubsection{Job Assignment Expression}

\begin{lstlisting}
assign_expr
	: logical_or_expr
	| unary_expr assign_op assign_expr
	;
\end{lstlisting}

\subsubsection{Job Assignment Operator}

\begin{lstlisting}
assign_op
	: `='
	| LARROW_OP
	| MUL_ASSIGN
	| DIV_ASSIGN
	| MOD_ASSIGN
	| ADD_ASSIGN
	| SUB_ASSIGN
	;
\end{lstlisting}


%----------------------------------------------------------YOUNGHOON}

%----------------------------------------------------------AKSHAI{
\subsection{Job Logical OR Expression}

The character sequence OR\_OP refers to the sequence "\textbardbl", which  
denotes the logical OR operator. The logical AND expressions that are 
separated by the logical OR operator associate left. The next section 
details how the logical AND expressions, logical\_and\_expr, which have 
higher precedence than the logical OR expression, are evaluated. 

\begin{lstlisting}
logical_or_expr
	: logical_and_expr
	| logical_or_expr OR_OP logical_and_expr
	;
\end{lstlisting}

Given a binary OR\_OP, the Logical OR expression evaluates to the 
integer 1, if either of the logical\_and\_expr evaluates to the integer 
1 and evaluates to 0, if both of the logical\_and\_expr evaluate to 0, 
where 1 stands for the truth value, true and 0, for false. The order of 
evaluation is left to right, also known as the "short circuit" 
evaluation, whereby the logical\_and\_expr on the right of the OR\_OP 
is evaluated if and only if the logical\_and\_expr on the left of the 
OR\_OP evaluated to 0. 

\subsection{Job Logical AND Expression}

The character sequence AND\_OP refers to the sequence "\&\&", which 
denotes the logical AND operator. The equality expressions that are 
separated by the logical OR operator associate left. The next section 
details how equality expressions, equality\_expr, which have higher 
precedence than the logical OR expression, are evaluated. 

\begin{lstlisting}
logical_and_expr
	: equality_expr
	| logical_and_expr AND_OP equality_expr
	;
\end{lstlisting}

Given a binary AND\_OP, the Logical AND expression evaluates to the 
integer 1, if both of the logical\_and\_expr evaluate to the integer 1 
and evaluates to 0, if either of the logical\_and\_expr evaluate to 0. 
The order of evaluation is again left to right, whereby the 
equality\_expr on the right of the AND\_OP is evaluated if and only 
if the equality\_expr on the left of the OR\_OP evaluated to 1.

\subsection{Job Equality Expression}

The character sequence EQ\_OP refers to the sequence "==" and the 
character sequence NE\_OP refers to the sequence "!=". These operators, 
equal to and not equal to, respectively, cause the expression to 
evaluate to the integer 0, for false, and 1, for true.  These operators 
that separate the relational expressions, relational\_expr, associate 
left. The operators EQ\_OP and NE\_OP have lower precedence than the 
operators that constitute the relational expressions, described in the 
next section. 

\begin{lstlisting}
equality_expr
	: relational_expr
	| equality_expr EQ_OP relational_expr
	| equality_expr NE_OP relational_expr
	;
\end{lstlisting}

Given two relational expressions, connected by a EQ\_OP or a NE\_OP, 
the equality expression evaluates to a 1, if and only if the left and 
the right relational expressions both evaluate to the same value in the 
case of a EQ\_OP and to different values in the case of a NE\_OP. 
Otherwise, the equality expression evaluates to a 0.

\subsection{Job Relational Expression}

The character sequence LE\_OP refers to the sequence "<=", for less 
than or equal to and GE\_OP refers to the sequence ">=", for greater 
than or equal to. The sequences '<' and '>' mean exactly the same as 
their mathematical counterpart relations. These operators also associate 
left to right and have lower precedence than the operators in the additive 
expression type, additive\_expr, described in the following section. The 
evaluation of a relational expression is once again a truth value, 
represented by the integers 0 and 1. 

\begin{lstlisting}
relational_expr
	: additive_expr
	| relational_expr `<' additive_expr
	| relational_expr `>' additive_expr
	| relational_expr LE_OP additive_expr
	| relational_expr GE_OP additive_expr
	;
\end{lstlisting}

Given two additive expressions, connected by the above mentioned operators, 
the expression evalutes to 1 if the mathematical relation represented by 
the operation is satisfied. Otherwise, the expression evaluates to 0. 

\subsection{Job Additive Expression}

The character sequence '+' and '-' mean addition and subtraction, 
respectively. These operators in Additive expressions, or additive\_expr, 
also associate left to right and have lower precedence than the 
multiplicative expressions, termed multiplicative\_expr, described next.

\begin{lstlisting}
additive_expr
	: multiplicative_expr
	| additive_expr `+' multiplicative_expr
	| additive_expr `-' multiplicative_expr
	;
\end{lstlisting}

Given two multiplicative expressions, connected by an additive operator, 
the expression evaluates to the result of applying the operator to the
operands. However, this depends on the type of the operands, which can
range from integer or doubles to matrices. In the case of the latter,
the evaluation of the expression results in a matrix, formed by the 
application of the operation on the multiplicative expressions. The
operands have to conform to strict type constraints as there is no
casting.

\subsection{Job Multiplicative Expression}

The character sequence '*' and '/' mean multiplication and division, 
respectively. The sequence '\%' represents the modulus operation. That
is, the remainder after the division of the right operand into the left
operand. These operators in Multiplicative expressions, or 
multiplicative\_expr, associate left to right and have lower precedence 
than unary expressions.

\begin{lstlisting}
multiplicative_expr
	: unary_expr
	| multiplicative_expr `*' unary_expr
	| multiplicative_expr `/' unary_expr
	| multiplicative_expr `%' unary_expr
	;
\end{lstlisting}

As with the additive expressions, the operators are applicable to types
where the mathematical equivalent is valid. For the case of multiplying
matrices, the requirement that the number of columns of the left operand be
equal to the number of rows of the right operand. With the data types, 
the result of the evaluation of the operation is contained within the set
of basic data types. The multiplication of a matrix expression with another 
results in a matrix expression. As with the additive expressions, there is 
no casting and the operands have to conform to the strict type constraints.

\subsection{Job Unary Expression}
Should talk about l-value if necessary.

\begin{lstlisting}
unary_expr
	: postfix_expr
	| `+' unary_expr
	| `-' unary_expr
	;
\end{lstlisting}

\subsection{Job PostFix Expression}

\begin{lstlisting}
postfix_expr
	: primary_expr
	| VARIABLE `[' array_idx_list `]' `[' array_idx_list `]'
	| IDENTIFIER `(' `)'
	| IDENTIFIER `(' argument_expr_list `)'
	;
\end{lstlisting}

\subsection{Job Primary Expression}

\begin{lstlisting}
primary_expr
	: IDENTIFIER
	| VARIABLE
	| NUMBER
	| STRING_LITERAL
	| `(' expr `)'
	;
\end{lstlisting}

\subsection{Job Array Index Element}

\begin{lstlisting}
array_idx_elmt
	: `~'
	| `~' NUMBER
	| NUMBER
	| NUMBER `~'
	| NUMBER `~' NUMBER
	;
\end{lstlisting}

\subsection{Job Array Index List}

\begin{lstlisting}
array_idx_list
	: array_idx_elmt
	| array_idx_list `,' array_idx_elmt
	;
\end{lstlisting}
\subsection{Job Argument Expression List}

\begin{lstlisting}
argument_expr_list
	: assign_expr
	| argument_expr_list `,' assign_expr
	;
\end{lstlisting}

%----------------------------------------------------------AKSHAI}
\section{Operators}
Operators here

\subsection{Operator $*$}

\subsection{Operator $/$}

\section{Built-in Terms}
Functions here

\subsection{sum()}

\subsection{Syntax subsection}

\section*{Appendix - Grammar}

MIPL's full grammar is here. MIPL's Yacc grammar has only one shift/reduce conflict, which C language also has, without using operator associativity declarations.

\lstinputlisting{../../build/mipl.grammar}
%\input{../../build/mipl_grammar.tex}
%\lstinputlisting{tablified_grammar}

% Appendix
%\appendix
%\section*{APPENDIX}
%\setcounter{section}{1}
%In this appendix, we measure

%\appendixhead{ZHOU}

% Acknowledgments
%\begin{acks}
%The authors would like to thank Dr. Maura Turolla of Telecom
%\end{acks}

% Bibliography
%\bibliographystyle{acmsmall}
%\bibliography{reference_manual_ref}

% History dates
%\received{February 2007}{March 2009}{June 2009}

% Electronic Appendix
%\elecappendix

\medskip

%\section{This is an example of Appendix section head}

\end{document}
