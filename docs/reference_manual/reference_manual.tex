% acmsmall-sample.tex, dated 4th Nov. 2011
% This is a sample file for ACM small trim journals
%
% Compilation using 'acmsmall.cls' - version 1.2, Aptara Inc.
% (c) 2010 Association for Computing Machinery (ACM)
%
% Questions/Suggestions/Feedback should be addressed to => "acmtexsupport@aptaracorp.com".
% Users can also go through the FAQs available on the journal's submission webpage.
%
% Steps to compile: latex, bibtex, latex latex
%
% For tracking purposes => this is v1.2 - Nov. 2011

\documentclass[prodmode,acmtecs]{acmsmall}

% Package to generate and customize Algorithm as per ACM style
\usepackage[ruled]{algorithm2e}
\usepackage{listings}
\usepackage{longtable}
\renewcommand{\algorithmcfname}{ALGORITHM}
\SetAlFnt{\large}
\SetAlCapFnt{\large}
\SetAlCapNameFnt{\large}
\SetAlCapHSkip{10pt}
\IncMargin{-\parindent}

% Metadata Information
\acmVolume{1}
\acmNumber{1}
\acmArticle{1}
\acmYear{2012}
\acmMonth{3}

% Document starts
\begin{document}

% Page heads
%\markboth{Young Hoon et al.}{MIPL Reference Manual}

% Title portion
\title{{MIPL: Mining Integrated Programming Language\\
Language Reference Manual}}
\author{Project Manager: Younghoon Jeon $<yj2231@columbia.edu>$\\
System Architect: Young Hoon Jung $<yj2244@columbia.edu>$\\
Language Expert: Jinhyung Park $<jp2105@columbia.edu>$\\
System Integrator: Daniel Wonjoon Song $<dws2127@columbia.edu>$\\
System Validation: Akshai Sarma $<as4107@columbia.edu>$
%\affil{Columbia University}
}

\begin{abstract}
Abstraction here.
\end{abstract}

%\category{C.2.2}{Computer-Communication Networks}{Network Protocols}

%\terms{Design, Algorithms, Performance}

%\keywords{Wireless sensor networks, media access control,
%multi-channel, radio interference, time synchronization}

%\acmformat{Zhou, G., Wu, Y., Yan, T., He, T., Huang, C., Stankovic,
%J. A., and Abdelzaher, T. F.  2010. A multifrequency MAC specially
%designed for  wireless sensor network applications.}

%\begin{bottomstuff}
%This work is supported by the National Science Foundation, under
%\end{bottomstuff}

\maketitle


\lstset{frame=single}

\section{Introduction}

Introduction here.

Item sample.
\begin{itemize}
\item item1 To the best of our knowledge, the MMSN protocol is the first
\item item2 Instead of using pairwise RTS/CTS frequency negotiation
\end{itemize}

% Head 1
\section{Lexical conventions}
MIPL has six kinds of tokens: identifiers, variables, numbers, strings,
expression operators, and other separators.  In general blanks, tabs,
newlines, and comments as described below are ignored except as they
serve to separate tokens. At least one of these characters is required
to separate otherwise adjacent identifiers, constants, and certain
operatorpairs.  If the input stream has been parsed into tokens up
to a given character, the next token is taken to include the longest
string of characters which could possibly constitute a token.

% Head 2
\subsection{Comments}

MIPL uses shell script-like comments, which begins with the character
\# and terminates at the end of the line, separated by the newline character.

% Head 3
\subsection{Identifiers}

An identifier is a sequence of letters that begins with lower case alphabets.
Upper and lower case letters are considered different.   Identifiers are
served for use as the name of Terms, the basic block of MIPL syntax.

\subsection{Variables}

A variable is a sequence of letters that begins with upper case alphabets
or the underscore character, \_, which means that this variable will not
be tracked.  Upper and lower case letters in the variable names are
considered different. 

\subsection{Numbers}

A number in MIPL is a floating number.  A number consists of an integer
part, a decimal point, a fraction part, an e, and an optionally signed integer
exponent. The integer and fraction parts both consist of a sequence of digits.
Either the integer part or the fraction
part (not both) may be missing; either the decimal point or the
e and the exponent (not both) may be missing.
Every floating constant is taken to be doubleprecision.

\subsection{Strings}

A string is a sequence of characters surrounded by double quotes or single
quotes.
A string has the type arrayofcharacters
(see below) and refers to an area of storage initialized with the given
characters. The compiler places a null byte ( \\0 ) at the end of each
string so that programs which scan the string can find its end. In a
string, the character ..  " ..  must be preceded by a ..\.. ; in
addition, the same escapes as described for character constants may be used.
NEED FIX

\subsection{Expression Operators}
Expression Operators will be explained in Built-in Operators and Jobs section.

\section{Data Types}

Data Types here.

\section{Syntax}

Syntax here

%----------------------------------------------------------JINHYUNG{
\subsection{Program}

A program looks like this:

\begin{lstlisting}
program
	: commands
	;
\end{lstlisting}


\subsection{Commands}

\begin{lstlisting}
commands
	: command commands
	| command
	;
\end{lstlisting}


\subsection{Command}

\begin{lstlisting}
command
	: fact
	| query
	| rule
	| job
	;
\end{lstlisting}

%----------------------------------------------------------JINHYUNG}
%----------------------------------------------------------YOUNGHOON{

\subsection{Term Expression}
\begin{lstlisting}
term_expr
	: term_expr `+' term_fact
	| term_expr `-' term_fact
	| term_fact
	;
\end{lstlisting}

Term Expression is an expression which belongs to a Term.  Term 
Expressions can consist of binary operators `+' and `-' along with Term
Factors.  These two operators left-associate Term Facts so that Term
Factors within a Term Expression can be computed with a left priority.

Term Expression, Term Factor, and Term Term are basic blocks that
consist Term Expression.  So these three rules can be applied within
Term Expression, by the definition of MIPL grammar.

\subsubsection{Term Factor}

\begin{lstlisting}
term_fact
	: term_fact `*' term_term
	| term_fact `/' term_term
	| term_term
	;
\end{lstlisting}

Term Factor is an expression which belongs to a Term Expression.  Term 
Factors can consist of binary operators `*' and `/' along with Term
Term.  These two operators left-associate Term Terms so that Term
Terms within a Term Factor can be computed with a left priority. Like,
mathematical notations, operators `*' and `/' have higher priority than
operators `+' and `-' since Term Facts are reduced 


\subsubsection{Term Term}
\begin{lstlisting}
term_term
	: VARIABLE
	| NUMBER
	| `(' term_expr `)'
	;
\end{lstlisting}

Term Term is a terminal expression of Term Expression and its derivables,
belonging to a Term Factor.  Term Terms can consist of a Variable or a
Number, which serve as the basic blocks of Term Expressions.  Also, a Term
Expression can be reduced to a Term Term with a pair of parentheses, which
allows the operators, `-', `+', `*', and `/' can appear recursively in a
Term Expression.  This also means that `(' and `)' operators have higher
operation priority than other operators.

\subsection{Arguments}
Arguments play a role in passing data from Facts to Job, by converting Facts
into matrices so that the Job computes the matrices by the algorithm
described in the Job.

\subsubsection{Argument Candidate}
\begin{lstlisting}
arg_cand
	: IDENTIFIER
	| IDENTIFIER `(' arg_list `)'
	| VARIABLE
	| `_'
	| NUMBER
	| STRING_LITERAL
	;
\end{lstlisting}

Argument Candidate is an Identifier, a Variable, an Anonymous
Variable, a Number, or a String.  An Identifier can have one
or more arguments within a pair of parentheses or no arguments.
This arguments again consist of Argument Candidates, which
allows a recursive form of argument definition.  For instance, 
$com(monitor, board(cpu, ram(4, 4)), P)$ is a valid form
of a Term declaration.

\subsubsection{Argument List}
\begin{lstlisting}
arg_list
	: arg_cand
	| arg_list `,' arg_cand
	;
\end{lstlisting}

Argument List is used for 1. A Fact declaration that calls a Job
2. A Term that has arguments 3. A Job definition.  Sharing the
same type of argument list for three different rules are possible
because there is not type and variable declaration in MIPL.  Thus,
a Job definition and a Job-calling Fact basically have the same
argument list.  There are a few diffences that will be checked
semantically at compile time and dynamically at runtime.  For example,
current implementation of MIPL does not support passing of nested
parameters so these errors are checked by Semantic Checker, which may
be eased later when MIPL is extended to support nested parameter passing
without changing its grammar.  Also, MIPL's Job definitions allows
variable numbers of return values dynamically, the generated program
checks if the numbers of return values from Job and the numbers of
Fact names are matched.  Otherwise, it fails to run.

\subsection{Job}

\begin{lstlisting}
job
	: IDENTIFIER `(' arg_list `)' `{' stmt_list `}'
	;
\end{lstlisting}

Job is MIPL's basic operation that provides matrix operations.
A Job definition denotes a number of arguments and a set of Job
Statements.  At runtime, a compiled Job is distributed over
a MapReduce clusters, computed, and delivered to the user. For
example, when a user loads two matrices and calls a Job giving those
matrices, the matrices are split into several smaller matrices,
distributed to MapReduce clusters, and computed.


\subsection{Job Statement}

\begin{lstlisting}
stmt
	: selection_stmt
	| compound_stmt
	| return_stmt
	| expr_stmt
	| iteration_stmt
	;
\end{lstlisting}

Job Statement is a sentence in a Job.  There are five types of
Job Statement: Job Selection Statement, Job Compound Statement,
Job Return Statement, Job Expression Statement, and Job Iteration
Statement.  Each of these will be explained in the following
sections.

\subsubsection{Job Statement List}

\begin{lstlisting}
stmt_list
	: stmt
	| stmt_list stmt
	;
\end{lstlisting}

Job Statement List is a set of Job Statement, used in Job
declarations and Job Compound Statement.


\subsubsection{Job Compound Statement}

\begin{lstlisting}
compound_stmt
	: `{' `}'
	| `{' stmt_list `}'
	;
\end{lstlisting}

Job Compound Statement is a Job Statement, which includes
zero or more Job Statements, embraced by a pair of curly
brackets.

\subsubsection{Job Return Statement}

\begin{lstlisting}
return_stmt
	: `@' expr `.'
	;

\end{lstlisting}

Job Return Statement is a sentence that returns a matrix.  Since
Job is likely executed on MapReduce clusters (unless configured
so or the matrix size is smaller than configured threshold), Job
Return Statement fetches the matrix.

There's no acceptable Job Return Statement like $@.$.  The
return operator $@$ is designed to deliver a matrix value from
MapReduce clusters to the user.  When a user want to quit the Job
in the mid of the Job, the user should use Job Control Statements
such as If Statement to do so.


\subsection{Job Expression Statement}

\begin{lstlisting}
expr_stmt
	: expr `.'
	;
\end{lstlisting}

Job Expression Statement is a Job Statement that includes a Job
Expression.  This allows users use Job Expressions in a Job.

\subsubsection{Job Selection Statement}

\begin{lstlisting}
selection_stmt
	: IF `(' expr `)' stmt
	| IF `(' expr `)' stmt ELSE stmt
	;
\end{lstlisting}

Job Selection Statement is a conditional control Job Statement,
which checks the value of given Job Expression and executes the
statements accordingly.  If the value of the Job Expression is
true, the first Job Statement will be executed.  If the value of
the expression is false and the ELSE statement is provided, this
statement will be executed.  The IF ELSE syntax is ambiguous,
however, by Yacc's default behavior, reduce precedes shift, which
results in that the ELSE is associated with closer IF.

\subsubsection{Job Iteration Statement}

\begin{lstlisting}
iteration_stmt
	: WHILE `(' expr `)' stmt
	| DO stmt WHILE `(' expr `)' `.'
	;
\end{lstlisting}

Job Iteration Statement is a statement, that repeatedly executes
the given Job Statement according to the value of Job Expression.

WHILE statement executes the given Job Statement while the Job
Expression's value is true.  DO WHILE statement executes the Job
Statement once first, and then executes the Job Statement repeatedly
while the Job Expression's value is true.


\subsection{Job Expression}

\begin{lstlisting}
expr
	: assign_expr
	;
\end{lstlisting}

Job Expression is a grammatical unit that conveys a value, which
includes a matrix or a number.  Whether a Job Expression contains
a matrix or a number is decided dynamically at runtime, since MIPL
is weak typed.


\subsubsection{Job Assignment Expression}

\begin{lstlisting}
assign_expr
	: logical_or_expr
	| unary_expr assign_op assign_expr
	;
\end{lstlisting}

Job Assignment Expression is a Job Expressions that assigns a value
to a Variable contained in the left-hand side expression.  The value
of Job Assignment Expression is the value newly assigned to the
Variable.


\subsubsection{Job Assignment Operator}

\begin{lstlisting}
assign_op
	: `='
	| LARROW_OP
	| MUL_ASSIGN
	| DIV_ASSIGN
	| MOD_ASSIGN
	| ADD_ASSIGN
	| SUB_ASSIGN
	;
\end{lstlisting}

Job Assignment Operator has seven types.  1. `=' and ``$<-$" are used
for Assignment.  2. ``*=" is Muliplication Assignment Operator.  3. 
``/=" is Division Assignment Operator.  4. "\%=" is Modular Assignment
Operator.  5. ``+=" is Addition Assignment Operator.  6. ``-=" is
Subtraction Assignment Operator.  Each Assignment Operators computes
the value of the operation using the left-hand side value and the
right-hand side value and assigns the value to the left-hand side
Variable.


%----------------------------------------------------------YOUNGHOON}
Akshai, would you make Job * Expressions to be subsubsection, so they belong to Job Expression.
%----------------------------------------------------------AKSHAI{
\subsection{Job Logical OR Expression}

\begin{lstlisting}
logical_or_expr
	: logical_and_expr
	| logical_or_expr OR_OP logical_and_expr
	;
\end{lstlisting}

\subsection{Job Logical AND Expression}

\begin{lstlisting}
logical_and_expr
	: equality_expr
	| logical_and_expr AND_OP equality_expr
	;
\end{lstlisting}

\subsection{Job Equality Expression}

\begin{lstlisting}
equality_expr
	: relational_expr
	| equality_expr EQ_OP relational_expr
	| equality_expr NE_OP relational_expr
	;
\end{lstlisting}

\subsection{Job Relational Expression}

\begin{lstlisting}
relational_expr
	: additive_expr
	| relational_expr `<' additive_expr
	| relational_expr `>' additive_expr
	| relational_expr LE_OP additive_expr
	| relational_expr GE_OP additive_expr
	;
\end{lstlisting}

\subsection{Job Additive Expression}

\begin{lstlisting}
additive_expr
	: multiplicative_expr
	| additive_expr `+' multiplicative_expr
	| additive_expr `-' multiplicative_expr
	;
\end{lstlisting}

\subsection{Job Multiplicative Expression}

\begin{lstlisting}
multiplicative_expr
	: unary_expr
	| multiplicative_expr `*' unary_expr
	| multiplicative_expr `/' unary_expr
	| multiplicative_expr `%' unary_expr
	;
\end{lstlisting}

\subsection{Job Unary Expression}
Should talk about l-value if necessary.

\begin{lstlisting}
unary_expr
	: postfix_expr
	| `+' unary_expr
	| `-' unary_expr
	;
\end{lstlisting}

\subsection{Job PostFix Expression}

\begin{lstlisting}
postfix_expr
	: primary_expr
	| VARIABLE `[' array_idx_list `]' `[' array_idx_list `]'
	| IDENTIFIER `(' `)'
	| IDENTIFIER `(' argument_expr_list `)'
	;
\end{lstlisting}

\subsection{Job Primary Expression}

\begin{lstlisting}
primary_expr
	: IDENTIFIER
	| VARIABLE
	| NUMBER
	| STRING_LITERAL
	| `(' expr `)'
	;
\end{lstlisting}

\subsection{Job Array Index Element}

\begin{lstlisting}
array_idx_elmt
	: `~'
	| `~' NUMBER
	| NUMBER
	| NUMBER `~'
	| NUMBER `~' NUMBER
	;
\end{lstlisting}

\subsection{Job Array Index List}

\begin{lstlisting}
array_idx_list
	: array_idx_elmt
	| array_idx_list `,' array_idx_elmt
	;
\end{lstlisting}
\subsection{Job Argument Expression List}

\begin{lstlisting}
argument_expr_list
	: assign_expr
	| argument_expr_list `,' assign_expr
	;
\end{lstlisting}

%----------------------------------------------------------AKSHAI}
\section{Operators}
Operators here

\subsection{Operator $*$}

\subsection{Operator $/$}

\section{Built-in Terms}
Functions here

\subsection{sum()}

\subsection{Syntax subsection}

\section*{Appendix - Grammar}

MIPL's full grammar is here. MIPL's Yacc grammar has only one shift/reduce conflict, which C language also has, without using operator associativity declarations.

\lstinputlisting{../../build/mipl.grammar}
%\input{../../build/mipl_grammar.tex}
%\lstinputlisting{tablified_grammar}

% Appendix
%\appendix
%\section*{APPENDIX}
%\setcounter{section}{1}
%In this appendix, we measure

%\appendixhead{ZHOU}

% Acknowledgments
%\begin{acks}
%The authors would like to thank Dr. Maura Turolla of Telecom
%\end{acks}

% Bibliography
%\bibliographystyle{acmsmall}
%\bibliography{reference_manual_ref}

% History dates
%\received{February 2007}{March 2009}{June 2009}

% Electronic Appendix
%\elecappendix

\medskip

%\section{This is an example of Appendix section head}

\end{document}

