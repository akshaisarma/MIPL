% acmsmall-sample.tex, dated 4th Nov. 2011
% This is a sample file for ACM small trim journals
%
% Compilation using 'acmsmall.cls' - version 1.2, Aptara Inc.
% (c) 2010 Association for Computing Machinery (ACM)
%
% Questions/Suggestions/Feedback should be addressed to => "acmtexsupport@aptaracorp.com".
% Users can also go through the FAQs available on the journal's submission webpage.
%
% Steps to compile: latex, bibtex, latex latex
%
% For tracking purposes => this is v1.2 - Nov. 2011

\documentclass[prodmode,acmtecs]{acmsmall}

% Package to generate and customize Algorithm as per ACM style
\usepackage[ruled]{algorithm2e}
\usepackage{listings}
\renewcommand{\algorithmcfname}{ALGORITHM}
\SetAlFnt{\small}
\SetAlCapFnt{\large}
\SetAlCapNameFnt{\large}
\SetAlCapHSkip{10pt}
\IncMargin{-\parindent}

% Metadata Information
\acmVolume{1}
\acmNumber{1}
\acmArticle{1}
\acmYear{2012}
\acmMonth{3}

% Document starts
\begin{document}

% Page heads
%\markboth{Young Hoon et al.}{MIPL Reference Manual}

% Title portion
\title{{MIPL: Mining Integrated Programming Language\\
Language Reference Manual}}
\author{Project Manager: Younghoon Jeon $<yj2231@columbia.edu>$\\
System Architect: Young Hoon Jung $<yj2244@columbia.edu>$\\
Language Expert: Jinhyung Park $<jp2105@columbia.edu>$\\
System Integrator: Daniel Wonjoon Song $<dws2127@columbia.edu>$\\
System Validation: Akshai Sarma $<as4107@columbia.edu>$
%\affil{Columbia University}
}

\begin{abstract}
Abstraction here.
\end{abstract}

%\category{C.2.2}{Computer-Communication Networks}{Network Protocols}

%\terms{Design, Algorithms, Performance}

%\keywords{Wireless sensor networks, media access control,
%multi-channel, radio interference, time synchronization}

%\acmformat{Zhou, G., Wu, Y., Yan, T., He, T., Huang, C., Stankovic,
%J. A., and Abdelzaher, T. F.  2010. A multifrequency MAC specially
%designed for  wireless sensor network applications.}

%\begin{bottomstuff}
%This work is supported by the National Science Foundation, under
%\end{bottomstuff}

\maketitle


\lstset{frame=single}

\section{Introduction}

Introduction here.

Item sample.
\begin{itemize}
\item item1 To the best of our knowledge, the MMSN protocol is the first
\item item2 Instead of using pairwise RTS/CTS frequency negotiation
\end{itemize}

% Head 1
\section{Lexical conventions}
MIPL has six kinds of tokens: identifiers, variables, numbers, strings,
expression operators, and other separators.  In general blanks, tabs,
newlines, and comments as described below are ignored except as they
serve to separate tokens. At least one of these characters is required
to separate otherwise adjacent identifiers, constants, and certain
operatorpairs.  If the input stream has been parsed into tokens up
to a given character, the next token is taken to include the longest
string of characters which could possibly constitute a token.

% Head 2
\subsection{Comments}

MIPL uses shell script-like comments, which begins with the character
\# and terminates at the end of the line, separated by the newline character.

% Head 3
\subsection{Identifiers}

An identifier is a sequence of letters that begins with lower case alphabets.
Upper and lower case letters are considered different.   Identifiers are
served for use as the name of Terms, the basic block of MIPL syntax.

\subsection{Variables}

A variable is a sequence of letters that begins with upper case alphabets
or the underscore character, \_, which means that this variable will not
be tracked.  Upper and lower case letters in the variable names are
considered different. 

\subsection{Numbers}

A number in MIPL is a floating number.  A number consists of an integer
part, a decimal point, a fraction part, an e, and an optionally signed integer
exponent. The integer and fraction parts both consist of a sequence of digits.
Either the integer part or the fraction
part (not both) may be missing; either the decimal point or the
e and the exponent (not both) may be missing.
Every floating constant is taken to be doubleprecision.

\subsection{Strings}

A string is a sequence of characters surrounded by double quotes or single
quotes.
A string has the type arrayofcharacters
(see below) and refers to an area of storage initialized with the given
characters. The compiler places a null byte ( \\0 ) at the end of each
string so that programs which scan the string can find its end. In a
string, the character ..  " ..  must be preceded by a ..\.. ; in
addition, the same escapes as described for character constants may be used.
NEED FIX

\subsection{Expression Operators}
Expression Operators will be explained in Built-in Operators and Jobs section.

\section{Data Types}

Data Types here.

\section{Syntax}

Syntax here

%----------------------------------------------------------JINHYUNG{
\subsection{Program}

A MIPL program is simple. Basically, the MIPL program looks like below:

\begin{lstlisting}
program
	: commands
	;
\end{lstlisting}

The MIPL program consists of commands. Each command consists of commmands again. MIPL also has the interpreter, so this command is a running unit for the interpreter. Here is the sample MIPL program:

\begin{lstlisting}
countPositive(A, SizeOfA) {
    I = 0.
    while (I < SizeOfA) {
        if (A[I] > 0) {
            I = I + 1.
        }
    }
}
cat(tom).
cat(tom)?
animal(X) <- cat(X).
animal(tom)?
\end{lstlisting}

This is the example of the MIPL program. In this example, there are five commands: $countPositive\{\}, cat()., cat()?, animal() <- cat().$, and $animal()?$. Each command can also include other commands. Each command can be identified by these: $\{\}, .,$ or $?$. These are used to determien the command type.

\subsection{Commands}

Including other commands in a command is permissible.

\begin{lstlisting}
commands
	: command commands
	| command
	;
\end{lstlisting}

The previous example in 4.1 shows that $countPositive\{\}$ includes several other commands. The command can be $a fact, a query, a rule,$ or $a job$.

\subsection{Command}

In MIPL, there are four types of commands: $fact, query, rule,$ and $job$.  

\begin{lstlisting}
command
	: fact
	| query
	| rule
	| job
	;
\end{lstlisting}

$fact$ is ended with $"."$. $fact$ is used to describe the fact. $query$ is ended with $"?"$. $query$ is used to check whether the fact is true or false. $query$ result returns $true$ or $false$. 


%----------------------------------------------------------JINHYUNG}
%----------------------------------------------------------YOUNGHOON{
\subsection{Term Expression}

Term Expression
\begin{lstlisting}
term_expr
	: term_expr '+' term_fact
	| term_expr '-' term_fact
	| term_fact
	;
\end{lstlisting}

\subsection{Term Factor}

Term Factor
\begin{lstlisting}
term_fact
	: term_fact '*' term_term
	| term_fact '/' term_term
	| term_term
	;
\end{lstlisting}


\subsection{Term Term}

\begin{lstlisting}
term_term
	: VARIABLE
	| NUMBER
	| '(' term_expr ')'
	;
\end{lstlisting}


\subsection{Argument Candidate}

\begin{lstlisting}
arg_cand
	: IDENTIFIER
	| IDENTIFIER '(' arg_list ')'
	| VARIABLE
	| '_'
	| NUMBER
	| STRING_LITERAL
	;
\end{lstlisting}


\subsection{Argument List}

\begin{lstlisting}
arg_list
	: arg_cand
	| arg_list ',' arg_cand
	;
\end{lstlisting}

\subsection{Job}

\begin{lstlisting}
job
	: IDENTIFIER '(' arg_list ')' '{' stmt_list '}'
	;
\end{lstlisting}


\subsection{Job Statement}

\begin{lstlisting}
stmt
	: selection_stmt
	| compound_stmt
	| return_stmt
	| expr_stmt
	| iteration_stmt
	;
\end{lstlisting}


\subsection{Job Statement List}

\begin{lstlisting}
stmt_list
	: stmt
	| stmt_list stmt
	;
\end{lstlisting}


\subsection{Job Compound Statement}

\begin{lstlisting}
compound_stmt
	: '{' '}'
	| '{' stmt_list '}'
	;
\end{lstlisting}


\subsection{Job Return Statement}

\begin{lstlisting}
return_stmt
	: '@' expr '.'
	;

\end{lstlisting}


\subsection{Job Expression Statement}

Probably should make all the expressions below subsubsections instead of subsections.

\begin{lstlisting}
expr_stmt
	: expr '.'
	;
\end{lstlisting}


\subsection{Job Selection Statement}

\begin{lstlisting}
selection_stmt
	: IF '(' expr ')' stmt
	| IF '(' expr ')' stmt ELSE stmt
	;
\end{lstlisting}


\subsection{Job Iteration Statement}

\begin{lstlisting}
iteration_stmt
	: WHILE '(' expr ')' stmt
	| DO stmt WHILE '(' expr ')' '.'
	;
\end{lstlisting}


\subsection{Job Expression}

\begin{lstlisting}
expr
	: assign_expr
	;
\end{lstlisting}


\subsection{Job Assignment Expression}

\begin{lstlisting}
assign_expr
	: logical_or_expr
	| unary_expr assign_op assign_expr
	;
\end{lstlisting}

\subsection{Job Assignment Operator}

\begin{lstlisting}
assign_op
	: '='
	| LARROW_OP
	| MUL_ASSIGN
	| DIV_ASSIGN
	| MOD_ASSIGN
	| ADD_ASSIGN
	| SUB_ASSIGN
	;
\end{lstlisting}


%----------------------------------------------------------YOUNGHOON}

%----------------------------------------------------------AKSHAI{
\subsection{Job Logical OR Expression}

\begin{lstlisting}
logical_or_expr
	: logical_and_expr
	| logical_or_expr OR_OP logical_and_expr
	;
\end{lstlisting}

\subsection{Job Logical AND Expression}

\begin{lstlisting}
logical_and_expr
	: equality_expr
	| logical_and_expr AND_OP equality_expr
	;
\end{lstlisting}

\subsection{Job Equality Expression}

\begin{lstlisting}
equality_expr
	: relational_expr
	| equality_expr EQ_OP relational_expr
	| equality_expr NE_OP relational_expr
	;
\end{lstlisting}

\subsection{Job Relational Expression}

\begin{lstlisting}
relational_expr
	: additive_expr
	| relational_expr '<' additive_expr
	| relational_expr '>' additive_expr
	| relational_expr LE_OP additive_expr
	| relational_expr GE_OP additive_expr
	;
\end{lstlisting}

\subsection{Job Additive Expression}

\begin{lstlisting}
additive_expr
	: multiplicative_expr
	| additive_expr '+' multiplicative_expr
	| additive_expr '-' multiplicative_expr
	;
\end{lstlisting}

\subsection{Job Multiplicative Expression}

\begin{lstlisting}
multiplicative_expr
	: unary_expr
	| multiplicative_expr '*' unary_expr
	| multiplicative_expr '/' unary_expr
	| multiplicative_expr '%' unary_expr
	;
\end{lstlisting}

\subsection{Job Unary Expression}
Should talk about l-value if necessary.

\begin{lstlisting}
unary_expr
	: postfix_expr
	| '+' unary_expr
	| '-' unary_expr
	;
\end{lstlisting}

\subsection{Job PostFix Expression}

\begin{lstlisting}
postfix_expr
	: primary_expr
	| VARIABLE '[' array_idx_list ']' '[' array_idx_list ']'
	| IDENTIFIER '(' ')'
	| IDENTIFIER '(' argument_expr_list ')'
	;
\end{lstlisting}

\subsection{Job Primary Expression}

\begin{lstlisting}
primary_expr
	: IDENTIFIER
	| VARIABLE
	| NUMBER
	| STRING_LITERAL
	| '(' expr ')'
	;
\end{lstlisting}

\subsection{Job Array Index Element}

\begin{lstlisting}
array_idx_elmt
	: '~'
	| '~' NUMBER
	| NUMBER
	| NUMBER '~'
	| NUMBER '~' NUMBER
	;
\end{lstlisting}

\subsection{Job Array Index List}

\begin{lstlisting}
array_idx_list
	: array_idx_elmt
	| array_idx_list ',' array_idx_elmt
	;
\end{lstlisting}
\subsection{Job Argument Expression List}

\begin{lstlisting}
argument_expr_list
	: assign_expr
	| argument_expr_list ',' assign_expr
	;
\end{lstlisting}

%----------------------------------------------------------AKSHAI}
\section{Operators}
Operators here

\subsection{Operator $*$}

\subsection{Operator $/$}

\section{Built-in Terms}
Functions here

\subsection{sum()}

\subsection{Syntax subsection}

\section*{Appendix}

MIPL's full grammar is here.
\lstinputlisting{../../build/mipl.grammar}
%\lstinputlisting{tablified_grammar}

% Appendix
%\appendix
%\section*{APPENDIX}
%\setcounter{section}{1}
%In this appendix, we measure

%\appendixhead{ZHOU}

% Acknowledgments
%\begin{acks}
%The authors would like to thank Dr. Maura Turolla of Telecom
%\end{acks}

% Bibliography
%\bibliographystyle{acmsmall}
%\bibliography{reference_manual_ref}

% History dates
%\received{February 2007}{March 2009}{June 2009}

% Electronic Appendix
%\elecappendix

\medskip

%\section{This is an example of Appendix section head}

\end{document}

