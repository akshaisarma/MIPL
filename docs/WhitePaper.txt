The Mining Integrated Programming Language (MIPL)
A White Paper
February 2012
1. Introduction to MIPL
MIPL is a language for Data Mining which provides methods to implement various sophisticated matrix-based algorithms and to retrieve the computed data easily by offering a novel, convenient way that converts matrics into a set of facts and vice versa.
1.1 Design Goals of MIPL
Whereas most of the matrix based languages, such as MATLAB or R, require the user to be fluent in complex syntax and a number of functions for matrix manipulation, MIPL provides two different aspects of the language to each user with different skills and interests by separating the data retrieval part from the algorithm implementation part, each of which plays a distinct role in the language.
1.1.1 FRQ: Simple and Easy to users
For users, MIPL is similar Prolog, because MIPL supports logic programming in a declarative way.  This part of MIPL is called FRQ, which stands for Facts, Rules, and Queries.  On the top of MIPL's FRQ, a Prolog programmer can easily write a data retrieval program, utilizing pre-written algorithms.
1.1.2 JOB: Efficient Matrix-based algorithms Development
While Prolog-like syntax provides the users an easy way to retrieve data, Prolog's syntax or its nested list type is not quite optimized for complex matrix operations or parallelization.  In MIPL, the algorithm implementation part that forms a function following MATLAB-like syntax is called JOB which provides linear algebra primitives that constitute key building blocks for various sets of Data Mining algorithms.  By separation of the JOB part from FRQ, MIPL frees the users who do not care the inside of the Data Mining algorithms by delegating the algorithm implementation to the Data Mining algorithm developers or researchers.
1.1.3 MFC: Matrix Facts Conversion
MFC or Matrix Facts Conversion, being one of the key concepts of MIPL, means facts in FRQ are converted to matrices, used for input arguments of a JOB.  Again, the output matrix from the JOB is converted to a set of facts in FRQ, so that the FRQ users can use these facts just as other facts combined with rules.
2. Linguistic Perspective
Due to the fact that MIPL has both characteristics of Prolog and MATLAB, it is important to understand what features belong to which part.
2.1. FRQ
[To be rephrased] 2.1.1 Primitive Data Types
In Facts, Rules, Query, the single data type is the term, which include numbers, strings, and compound terms.  Compound terms consist of a "functor" and a number of "arguments", which are again terms.
An atom is a general-purpose name with no inherent meaning. Examples of atoms include x, blue, 'Taco', and 'some atom'.
Numbers can be floats or integers.
 A compound term is composed of an atom called a "functor" and a number of "arguments", which are again terms. Compound terms are ordinarily written as a functor followed by a comma-separated list of argument terms, which is contained in parentheses. The number of arguments is called the term's arity. An atom can be regarded as a compound term with arity zero.
2.1.2. Variables
Variables are denoted by a string consisting of letters, numbers and underscore characters, and beginning with an upper-case letter or underscore. Variables closely resemble variables in logic in that they are placeholders for arbitrary terms.
2.2 JOB
2.2.1 Primitive Data Types
In JOB definitions, allowed primitive data types are integers, floating-point numbers.  Unlike MATLAB, MIPL does not support complex numbers, which is unusually used in most of Data Mining algorithms.
2.2.2 Variables
Unlike MATLAB, variables in JOB definitions follow the rule for variables in FRQ.  This is for the users who use both parts of MIPL - FRQ and JOB - to avoid confusion on the variable rules.
2.3. Comparison to Prolog
While some complex features have been removed from Prolog to reduce complexity and to increase usability, MIPL contains core logic functionalities in addition to newly introduced features.
2.3.1 Dynamic Rule Definition
Prolog interpreters require rules and facts to be loaded from a file.  MIPL allows the users, however, to dynamically declare rules and facts in the command prompt as well as queries.  This difference
2.3.2 Features Removed from Prolog
Prolog's computational part has been removed because MIPL's FRQ is intended to provide the users a simple way to retrieve data.
[Tentative] 2.3.2.1 List
List, one of the most frequently used features of Prolog, is removed in MIPL mostly because matrices replace lists in MIPL.  Also, list is not the adequate type for representing input and output data of Data Mining.
2.3.2.2 Grammar Rules (DFA)
2.4. Comparison to MATLAB
[To be decided]
2.4.3 Features Removed from MATLAB
No complex data type.  Real numbers only.
3. Architecture Neutral, Virtual Machine Neutral, Portable
Similarly to Java, MIPL's target code is designed to run on a virtual machine.  MIPL, however, does not generate only one kind of code targeted at a specific virtual machine, but is also able to work for various virtual machines, by having several code generation component plugins.  This means MIPL is independent from virtual machines as well as from architecture, and it gives you more portability even when a certain virtual machine is not portable to the target machine.
3.1. Virtual Machine
Through plugin architecture MIPL compiler can generate different types of intermediate codes at the option request of the users.  By default, MIPL generates Java Bytecode that runs on Java Virtual Machine.  Users may insert a new codde generator which fits in the code generator plugin architecture so that the generated code can run on the new type of virtual machine.  For example, for future work we plan to provide MIPL virtual machine along with MIPL intermediate code generator plugin for MIPL compiler.
/* 4. Dynamic and Looseness
Every rules, facts and JOBs are evaluated at run time upon the user's query from the command prompt or the MIPL program.  This means, dynamic type checking including variable types or matrix computability is determined at run time, unlike syntax checking which is done at interpret or compile time.
4.1. Lazy Binding
Rule binding occurs at run time.
4.2. Loose Types
Each variable is declared without a type. Dynamic Typing!!!! fastercompilation,genericcode
Weak Typing . Implicit type conversion is allowed
. Ex.  C, C++, JavaScript
. Advantages: easier to write programs?

5. High Performance
MIPL's architecture enables four notable optimization techniques including Parallelization, Sparse Matrix Handling, GPGPU computation, and Matrix Caching.
5.1. Parallelization
MapReduce
5.2. Sparse Matrix Handing
5.3. GPGPU Computation
5.4. Matrix Caching */
