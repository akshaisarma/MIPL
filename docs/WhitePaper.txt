The Mining Integrated Programming Language (MIPL): A White Paper
February 22, 2012

Younghoon Jeon (yj2231)
Young Hoon Jung (yj2244)
Jinhyung Park (jp2105)
Wonjoon Song (dws2127)
Akshai Sarma (as4107)


1. Introduction to MIPL
MIPL is a language for Data Mining which provides methods to implement various sophisticated matrix-based algorithms and to retrieve the computed data easily by offering a novel, convenient way that converts matrices into a set of facts and vice versa.

1.1 Design Goals of MIPL
Most of the languages that provide matrix based computations, such as MATLAB or R, require the user to be fluent in complex syntaxes and a number of functions for matrix manipulations. MIPL, on the other hand, provides two simple yet different aspects of the language to every user independent of their proficiency in Data Mining. The language handles different skills and interests by separating the data retrieval part of the language from the algorithm implementation part, each of which plays a distinct role in the language.

1.1.1 FRQ: Facts, Rules and Queries
The data retrieval part of the language is called FRQ, which stands for Facts, Rules, and Queries. From the user perspective, this part of MIPL is similar Prolog, which supports logic programming in a declarative way. However, the syntax is extended for the purposes of data mining and supports various useful constructs such as regular expressions in rules and facts, allowing the user to express complex sentences elegantly and concisely.  This also allows the user to very easily describe the data to be retrieved by defining rules and facts and then defining queries. On the top of MIPL's FRQ, even a casual programmer familiar with Prolog, can easily write a data retrieval program, utilizing pre-written algorithms.

1.1.2 JOB: For Efficient Matrix-based Algorithm Development 
While the Prolog like syntax in the FRQ provides the users an easy way to retrieve data, it is not a viable method for the development of algorithms to use for the data retrieval. The FRQ's syntax, which uses nested list types is not convenient nor is it optimized for complex matrix operations or parallelization. To solve this issue, MIPL has a second component, called JOB, which uses a seperate syntax from FRQ. JOB provides the algorithm implementation part that takes inspiration from MATLAB's syntax, to provide an efficient means of representation for algorithm creation. JOB is intended for serious users, who have sufficient programming experience and want to create a new "JOB". To facilitate this, JOB also provides various linear algebra primitives that constitute key building blocks for various sets of Data Mining algorithms.  By separating JOB from FRQ, MIPL can be used by users with a varying degree of data mining and programming experiences. It frees the users who simply want to create a data retrieval program from understanding or creating complex algorithms by separating and delegating this task to more serious developers or researchers.

1.1.3 MFC: Matrix Facts Conversion
FRQ and JOB are logically separated for the user but can work together in synergy through the MFC, which stands for Matrix Facts Conversion. This is one of the key concepts of MIPL. The MFC allows facts in FRQ to be converted to matrices, used for input arguments of a JOB.  Conversely, the output matrix from JOB can be converted to a set of facts through MFC, so that FRQ users can use these facts in combination with other rules and facts for further computation. The MFC collects a rule with a set of facts under a matrix, much like how it would be represented as a table.

2. Linguistic Perspective
Due to the fact that MIPL is a combination of FRQ and JOB, linked by MFC and since it has both characteristics of Prolog and MATLAB, it is important to clarify what features belong to which part.

2.1. FRQ

[To be rephrased] 2.1.1 Primitive Data Types
In Facts, Rules, Queries, the single logical data type is the term. A term can include numbers, strings, and compound terms. Compound terms consist of a "functor" and a number of "arguments", which are again terms.
An atom is a general-purpose name with no inherent meaning. Examples of atoms include x, blue, 'Taco', and 'some atom'.
Numbers can be floats or integers.
A compound term is composed of an atom called a "functor" and a number of "arguments", which are again terms. Compound terms are ordinarily written as a functor followed by a comma-separated list of argument terms, which is contained in parentheses. The number of arguments is called the term's arity. An atom can be regarded as a compound term with arity zero.

2.1.2. Variables
Variables are denoted by a string consisting of letters, numbers and underscore characters, and beginning with an upper-case letter or underscore. Variables closely resemble variables in logic in that they are placeholders for arbitrary terms.

2.2 JOB

2.2.1 Primitive Data Types
In JOB definitions, allowed primitive data types are integers, floating-point numbers.  Unlike MATLAB, MIPL does not support complex numbers, which are not used frequently in most of Data Mining algorithms.

2.2.2 Variables
Unlike MATLAB, variables in JOB definitions follow the rule for variables in FRQ.  This is for the users who use both parts of MIPL - FRQ and JOB - to avoid confusion on the variable rules.

2.3. Comparison to Prolog
While some complex features have been removed from Prolog to reduce complexity and to increase usability, MIPL contains core logic functionalities in addition to newly introduced features.

2.3.1 Dynamic Rule Definition
Prolog interpreters require rules and facts to be loaded from a file.  MIPL allows the users, however, to dynamically declare rules and facts in the command prompt as well as queries.  This difference

2.3.2 Features Removed from Prolog
Prolog's computational part has been removed because MIPL's FRQ is intended to provide the users a simple way to retrieve data.

[Tentative] 2.3.2.1 List
List, one of the most frequently used features of Prolog, is removed in MIPL mostly because matrices replace lists in MIPL.  Also, list is not the adequate type for representing input and output data of Data Mining.

2.3.2.2 Grammar Rules (DFA)

2.4. Comparison to MATLAB
[To be decided]

2.4.3 Features Removed from MATLAB
No complex data type.  Real numbers only.

3. MIPL Buzzwords
In order to characterize MIPL, we define some of the key features of our language in the form of buzzwords. MIPL: A platform and architecture neutral, portable, dynamic, lazy, high performance, easy, interpreted language.

3.1 Architecture Neutral 
Similar to Java, MIPL's target code is designed to run on a virtual machine.  MIPL currently produces Java bytecode itself as the compilation output, allowing it to be run on Java Virtual Machines for architecture neutrality.  

3.1.1. Virtual Machine Neutral
MIPL is not limited to a particular virtual machine. Because MIPL is open, through the modular plugin architecture, the MIPL compiler can be augmented to generate different types of intermediate codes at the behest of its users.  By default, MIPL generates Java Bytecode that runs on Java Virtual Machine.  Users are free to insert a new code generator so that the generated code can run on a new type of virtual machine. This means MIPL is independent from virtual machines as well as from architecture.

3.2 Portable
As MIPL is both architecture and virtual machine independent, it gives the user high portability. When a certain virtual machine is not portable to the target machine, the MIPL user can replace the code generation module with one that does match the target. 

3.3 Dynamic
Every rules, facts and JOBs are evaluated at run time upon the user's query from the command prompt or the MIPL program.  This means, dynamic type checking including variable types or matrix computability is determined at run time, unlike static typing, which is done at compile time.

3.3.1 Typing
Each variable is declared without a type. In other words, MIPL is dynamically typed. With dynamic typing and type conversion, MIPL users can produce code very fast, similar to a scripting language.

3.4 Lazy
MIPL deals with the binding of rules and facts in the FRQ, at runtime. This provides for fast and easy compilation. MIPL includes a command prompt that allows the user to enter queries. As the query is applied, binding is done on the rules and facts.

3.5 High Performance
MIPL is designed to have high performance. With the vast amounts of data dealt with in the data mining field, it is imperative that the language designed for it be of high performance. As such, MIPL's architecture enables four notable optimization techniques, which are Parallelization, Sparse Matrix Handling, GPGPU computation, and Matrix Caching.

3.5.1 Parallelization
MIPL includes a MapReduce component. After generating code, the MIPL execution environment can be linked to run on the MapReduce framework to efficiently compute on large data sets and complex rules.

3.5.2 Sparse Matrix Handing

3.5.3 GPGPU Computation

3.5.4 Matrix Caching

3.6 Simple
MIPL's FRQ is simple to use. A user with only a little programming experience can quickly learn the syntax of the FRQ and create a complete data mining program very quickly. However, the simplicity does not sacrifice the capabilities of MIPL as JOB can be used to develop by experienced users to generate powerful new algorithms by using and defining in-built operations.

3.7 Interpreted
MIPL is designed to run on an virtual machine and as such, its code is translated on the fly to native machine code. However, MIPL is currently designed to run on the Java Virtual Machine, which can incorporate Just In Time compilation to decrease the performance overhead of interpretation.
