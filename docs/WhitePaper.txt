The Mining Integrated Programming Language (MIPL): A White Paper
February 22, 2012

Younghoon Jeon (yj2231)
Young Hoon Jung (yj2244)
Jinhyung Park (jp2105)
Wonjoon Song (dws2127)
Akshai Sarma (as4107)


1. Introduction to MIPL
MIPL is a language for Data Mining which provides methods to implement various sophisticated matrix-based algorithms and to retrieve the computed data easily by offering a novel, convenient way that converts matrices into a set of facts and vice versa.

1.1 Design Goals of MIPL
Most of the languages that provide matrix based computations, such as MATLAB or R, require the user to be fluent in complex syntaxes and a number of functions for matrix manipulations. MIPL, on the other hand, provides two simple yet different aspects of the language to every user independent of their proficiency in Data Mining. The language handles different skills and interests by separating the data retrieval part of the language from the algorithm implementation part, each of which plays a distinct role in the language. In addition to MIPL.s approach to matrix-based algorithm implementation, its flexible architecture allows it to easily accelerate and parallelize the code using GPGPU and MapReduce.

1.1.1 FRQ: Facts, Rules and Queries
The data retrieval part of the language is called FRQ, which stands for Facts, Rules, and Queries. From the user perspective, this part of MIPL is similar Prolog, which supports logic programming in a declarative way. However, the syntax is extended for the purposes of Data Mining and supports various useful constructs such as regular expressions in rules and facts, allowing the user to express complex sentences elegantly and concisely. This also allows the user to very easily describe the data to be retrieved by defining rules and facts and then defining queries. On the top of MIPL's FRQ, even a casual programmer familiar with Prolog, can easily write a data retrieval program, utilizing pre-written algorithms.

1.1.2 JOB: For Efficient Matrix-based Algorithm Development
While the Prolog like syntax in the FRQ provides the users an easy way to retrieve data, it is not a viable method for the development of algorithms to use for the data retrieval. The FRQ's syntax, which uses nested list types is not convenient nor is it optimized for complex matrix operations or parallelization. To solve this issue, MIPL has a second component, called JOB, which uses separated syntax from FRQ. JOB provides the algorithm implementation part that takes inspiration from MATLAB's syntax, to provide an efficient means of representation for algorithm creation. JOB is intended for serious users, who have sufficient programming experience and want to create a new "JOB". To facilitate this, JOB also provides various linear algebra primitives that constitute key building blocks for various sets of Data Mining algorithms. By separating JOB from FRQ, MIPL can be used by users with a varying degree of Data Mining and programming experiences. It frees the users who simply want to create a data retrieval program from understanding or creating complex algorithms by separating and delegating this task to more serious developers or researchers.

1.1.3 MFC: Matrix Facts Conversion
FRQ and JOB are logically separated for the user but can work together in synergy through the MFC, which stands for Matrix Facts Conversion. This is one of the key concepts of MIPL. The MFC allows facts in FRQ to be converted to matrices, used for input arguments of a JOB. Conversely, the output matrix from JOB can be converted to a set of facts through MFC, so that FRQ users can use these facts in combination with other rules and facts for further computation. The MFC collects a rule with a set of facts under a matrix, much like how it would be represented as a table.

2. MIPL Use Case Scenarios
Here are brief Use Case Scenarios that can happen with MIPL.

2.1 Advertisement Pricing
When a web-platform administrator needs to determine how much of advertisement pricing is appropriate for each web page, PageRank algorithm can be used.  With page relation data gathered and a PageRank algorithm implemented in MIPL, the user calculated proper values by launching PageRank everyday.

2.2 Weather Forecast
One of the evident examples is weather forecast, as most of the users want to retrieve weather forecast information easily while the sophisticated algorithms like regression or random forest are hid behind the scene. Once weather forecast algorithm is implemented in JOB, the users can retrieve the forecasted weather data from the massively huge raw data, by giving several conditions, like in California, from 3-6PM tomorrow. 
 
3. MIPL Language Concept
In order to characterize MIPL, we define some of the key features of our language. MIPL is a platform and architecture neutral, portable, dynamic, high performance, easy, and interpretable language.

3.1 Architecture Neutral
Similar to Java, MIPL's target code is designed to run on a virtual machine. MIPL currently produces Java bytecode itself as the compilation output, allowing it to be run on Java Virtual Machines for architecture neutrality.

3.1.1. Virtual Machine Neutral
MIPL is not limited to a particular virtual machine. Because MIPL is open, through the modular plugin architecture, the MIPL compiler can be augmented to generate different types of intermediate codes at the behest of its users. By default, MIPL generates Java Bytecode that runs on Java Virtual Machine. Users are free to insert a new code generator so that the generated code can run on a new type of virtual machine. This means MIPL is independent from virtual machines as well as from architecture.

3.2 Simple
MIPL's FRQ is simple to use. A user with only a little programming experience can quickly learn the syntax of the FRQ and create a complete Data Mining program very quickly. However, the simplicity does not sacrifice the capabilities of MIPL as JOB can be used to develop by experienced users to generate powerful new algorithms by using and defining in-built operations.

3.3 Portable
As MIPL is both architecture and virtual machine independent, it gives the user high portability. When a certain virtual machine is not portable to the target machine, the MIPL user can replace the code generation module with one that does match the target.

3.4 Dynamic
Every rules, facts and JOBs are evaluated at run time upon the user's query from the command prompt or the MIPL program. This means, dynamic type checking including variable types or matrix computability is determined at run time, unlike static typing, which is done at compile time.

3.4.1 Dynamic  and Weak Typing
Each variable is declared without a type. In other words, MIPL is dynamically typed. With dynamic typing and type conversion, MIPL users can produce code very fast, similar to a scripting language.

3.4.2 Lazy Rule Binding
MIPL deals with the binding of rules and facts in the FRQ, at runtime. This provides for fast and easy compilation. MIPL includes a command prompt that allows the user to enter queries. As the query is applied, binding is done on the rules and facts.

3.5 High Performance
MIPL is designed to have high performance. With the vast amounts of data dealt with in the Data Mining field, it is imperative that the language designed for it be of high performance. As such, MIPL.s flexible architecture allows the users to replace plugins for execution module to enable notable optimization techniques, which are Parallelization and GPGPU computation. 

3.5.1 Parallel
MIPL.s default execution module includes a MapReduce component. After generating code, the MIPL execution environment can be linked to run on the MapReduce framework to efficiently compute on large data sets and complex rules, in a fault-tolerant and scalable way.

3.5.2 H/W Accelerated
As recent computing nodes come with GPUs and GPUs performs well in matrix computations, MIPL also provides a way to utilize accelerators, in most cases GPUs, on the local or remote nodes.  MIPL.s default execution module utilizes GPUs on MapReduce nodes through OpenGL APIs.

3.6 Interpretable
MIPL is designed to run on a virtual machine and as such, its code is translated on the fly to native machine code. Nonetheless, MIPL is also designed to run on the user command line, which can incorporate the virtual machine with dynamically interpreted codes.
